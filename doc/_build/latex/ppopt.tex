%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsable pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Overview}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{PPOPT}
\date{Sep 28, 2021}
\release{1.0.2}
\author{Dustin Kenefake, Efstratios Pistikopoulos}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
MPO is a multiparametric programming Solver written in Python, meant for solving general mpQPs and mpLPs with support for mixed integer and Quadratically constrained problems prospectively in the future. Optimized implementations of combinatorial algorithms and graph\sphinxhyphen{}based algorithms have been implemented. A focus of this Solver is to implement parallel and scalable algorithms for multithreading compute.


\chapter{Installation}
\label{\detokenize{index:installation}}
\sphinxAtStartPar
All you need to do is the following pip command in the relevant console.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip install git+https://github.com/dkenefake/mpo.git
\end{sphinxVerbatim}


\chapter{Tutorial}
\label{\detokenize{index:tutorial}}

\section{Solving a MPQP Program}
\label{\detokenize{tutorial:solving-a-mpqp-program}}\label{\detokenize{tutorial::doc}}
\sphinxAtStartPar
Here we are going to solve a classic transportation problem with multiparametric uncertainty. We have a set of plants and a set of markets with corresponding supplies and demand, and we want to minimize the transport cost between the plants and ensuring we satisfy all market demand. The multiparametric formulation is fleshed out in more detail in Multiparametric Optimization and Control by Pistikopolous et al.

\sphinxAtStartPar
This optimization problem leads to the following multiparametric optimization problem, with θ representing the markets’ uncertain demands.
\begin{equation*}
\begin{split}\min_{x} \frac{1}{2}\left[\begin{matrix}x_0\\x_1\\x_2\\x_3\end{matrix}\right]^{T}\left[\begin{matrix}306.0 & 0 & 0 & 0\\0 & 324.0 & 0 & 0\\0 & 0 & 324.0 & 0\\0 & 0 & 0 & 252.0\end{matrix}\right]\left[\begin{matrix}x_0\\x_1\\x_2\\x_3\end{matrix}\right]+\left[\begin{matrix}25.0\\25.0\\25.0\\25.0\end{matrix}\right]^T\left[\begin{matrix}x_0\\x_1\\x_2\\x_3\end{matrix}\right]\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{equation*}
\begin{split}
\text{s.t. }\left[\begin{matrix}1.0 & 1.0 & 0 & 0\\0 & 0 & 1.0 & 1.0\\-1.0 & 0 & -1.0 & 0\\0 & -1.0 & 0 & -1.0\\-1.0 & 0 & 0 & 0\\0 & -1.0 & 0 & 0\\0 & 0 & -1.0 & 0\\0 & 0 & 0 & -1.0\end{matrix}\right]\left[\begin{matrix}x_0\\x_1\\x_2\\x_3\end{matrix}\right] & \leq\left[\begin{matrix}350.0\\600.0\\0\\0\\0\\0\\0\\0\end{matrix}\right]+\left[\begin{matrix}0 & 0\\0 & 0\\-1.0 & 0\\0 & -1.0\\0 & 0\\0 & 0\\0 & 0\\0 & 0\end{matrix}\right]\left[\begin{matrix}\theta_0\\\theta_1\end{matrix}\right]\\
\left[\begin{matrix}1.0 & 0\\0 & 1.0\\-1.0 & 0\\0 & -1.0\end{matrix}\right]\left[\begin{matrix}\theta_0\\\theta_1\end{matrix}\right] & \leq\left[\begin{matrix}1e+03\\1e+03\\0\\0\end{matrix}\right]
\end{split}
\end{equation*}\end{split}
\end{equation*}
\sphinxAtStartPar
Using MPO, this is translated as the following python code. (The latex above was generated for me with \sphinxcode{\sphinxupquote{prog.latex()}} if you were wondering if I typed that all out by hand.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{350}\PYG{p}{,} \PYG{l+m+mi}{600}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{25} \PYG{o}{*} \PYG{n}{make\PYGZus{}column}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{F} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Q} \PYG{o}{=} \PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{diag}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{153}\PYG{p}{,} \PYG{l+m+mi}{162}\PYG{p}{,} \PYG{l+m+mi}{162}\PYG{p}{,} \PYG{l+m+mi}{126}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{CRa} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{vstack}\PYG{p}{(}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CRb} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{H} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{F}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{prog} \PYG{o}{=} \PYG{n}{MPQP\PYGZus{}Program}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{H}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{CRa}\PYG{p}{,} \PYG{n}{CRb}\PYG{p}{,} \PYG{n}{F}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
But before you go forward and solve this, I would always recommend processing the constraints. Removing all strongly and weakly redundant constraints and rescaling them leads to significant performance increases and robustifying the numerical stability. In MPO, processing the constraints is a simple task.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{prog}\PYG{o}{.}\PYG{n}{process\PYGZus{}constraints}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This results in the following (identical) multiparametric optimization problem. We were able to remove 2 constraints! And we reduced the condition number of the constraints.
\begin{equation*}
\begin{split}\min_{x} \frac{1}{2}\left[\begin{matrix}x_0\\x_1\\x_2\\x_3\end{matrix}\right]^{T}\left[\begin{matrix}306.0 & 0 & 0 & 0\\0 & 324.0 & 0 & 0\\0 & 0 & 324.0 & 0\\0 & 0 & 0 & 252.0\end{matrix}\right]\left[\begin{matrix}x_0\\x_1\\x_2\\x_3\end{matrix}\right]+\left[\begin{matrix}25.0\\25.0\\25.0\\25.0\end{matrix}\right]^T\left[\begin{matrix}x_0\\x_1\\x_2\\x_3\end{matrix}\right]\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{equation*}
\begin{split}
\text{s.t. }\left[\begin{matrix}0.7071 & 0.7071 & 0 & 0\\0 & 0 & 0.7071 & 0.7071\\-0.5774 & 0 & -0.5774 & 0\\0 & -0.5774 & 0 & -0.5774\\-1.0 & 0 & 0 & 0\\0 & -1.0 & 0 & 0\\0 & 0 & -1.0 & 0\\0 & 0 & 0 & -1.0\end{matrix}\right]\left[\begin{matrix}x_0\\x_1\\x_2\\x_3\end{matrix}\right] & \leq\left[\begin{matrix}247.5\\424.3\\0\\0\\0\\0\\0\\0\end{matrix}\right]+\left[\begin{matrix}0 & 0\\0 & 0\\-0.5774 & 0\\0 & -0.5774\\0 & 0\\0 & 0\\0 & 0\\0 & 0\end{matrix}\right]\left[\begin{matrix}\theta_0\\\theta_1\end{matrix}\right]\\
\left[\begin{matrix}1.0 & 0\\0 & 1.0\\-1.0 & 0\\0 & -1.0\end{matrix}\right]\left[\begin{matrix}\theta_0\\\theta_1\end{matrix}\right] & \leq\left[\begin{matrix}1e+03\\1e+03\\0\\0\end{matrix}\right]
\end{split}
\end{equation*}\end{split}
\end{equation*}
\sphinxAtStartPar
That wasn’t that bad, and we were able to cut away some constraints that didn’t matter in the process! Now we are ready to solve it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{solution} \PYG{o}{=} \PYG{n}{mpo}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now we have the solution, we can either export the solution via the micropop module, or we can plot it. Let’s plot it here. The extra arguments mean we are saving a picture of the plot and displaying it to the user (you can give a file path, so it saves somewhere that is not the current working directory).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{parametric\PYGZus{}plot}\PYG{p}{(}\PYG{n}{solution}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transport.png}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{n}{show} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Multiparametric Algorithms}
\label{\detokenize{algorithm_overview:multiparametric-algorithms}}\label{\detokenize{algorithm_overview::doc}}
\sphinxAtStartPar
This section will give a basic overview of the algorithms used in this package for solving the multiparametric programming problems. All current algorithms depend on exploring the theta space of the problem, choosing differing ways to do so.


\subsection{Geometric Algorithm}
\label{\detokenize{algorithm_overview:geometric-algorithm}}
\sphinxAtStartPar
The Geometric algorithm is based on exporing the feasible space. The name of the algorithm comes from the fact that it is geometrically exploring the space by flipping critical region facets.

\sphinxAtStartPar
This is best used in situations where the number of theta dimensions is small and scales well with number of variables and constraints.


\subsection{Combinatorial Algorithm}
\label{\detokenize{algorithm_overview:combinatorial-algorithm}}
\sphinxAtStartPar
The combinatorial algorithm is based on exploring feasible active set combinations. It is called the combinatorial algorithm due the fact that th…. This is the most robust multiparametric algorithm as it handles both primal and dual degeneracy and will always fully solve the multiparametric programming problem.

\sphinxAtStartPar
This is best used in situations where the number of constraints and variables is small and scales well with number of theta dimensions.


\subsection{Graph Algorithm}
\label{\detokenize{algorithm_overview:graph-algorithm}}
\sphinxAtStartPar
The graph algorithm is based on exploring the connected graph of active set combinations. This can be viewed as a combination certain aspects of the Geometric algorithm and the Combinatorial algorithm.

\sphinxAtStartPar
This is a general purpose algorithm that scales ok with number of variables, constraints, and parameters. However this algorithm has been shown to be unstable in that it fails to fully solve some multiparametric programs with poor conditioning.


\chapter{API}
\label{\detokenize{index:api}}

\section{ppopt package}
\label{\detokenize{ppopt:ppopt-package}}\label{\detokenize{ppopt::doc}}

\subsection{Subpackages}
\label{\detokenize{ppopt:subpackages}}

\subsubsection{ppopt.geometry package}
\label{\detokenize{ppopt.geometry:ppopt-geometry-package}}\label{\detokenize{ppopt.geometry::doc}}

\paragraph{Submodules}
\label{\detokenize{ppopt.geometry:submodules}}

\paragraph{ppopt.geometry.polytope module}
\label{\detokenize{ppopt.geometry:module-ppopt.geometry.polytope}}\label{\detokenize{ppopt.geometry:ppopt-geometry-polytope-module}}\index{module@\spxentry{module}!ppopt.geometry.polytope@\spxentry{ppopt.geometry.polytope}}\index{ppopt.geometry.polytope@\spxentry{ppopt.geometry.polytope}!module@\spxentry{module}}\index{Polytope (class in ppopt.geometry.polytope)@\spxentry{Polytope}\spxextra{class in ppopt.geometry.polytope}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.geometry:ppopt.geometry.polytope.Polytope}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ppopt.geometry.polytope.}}\sphinxbfcode{\sphinxupquote{Polytope}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
This is a basic convex polytope class in n\sphinxhyphen{}dimensions. In future releases this will take the place of explicitly passing around matrix pairs {[}A, b{]} and lead to a simplification of the code base.

\end{fulllineitems}



\paragraph{ppopt.geometry.polytope\_operations module}
\label{\detokenize{ppopt.geometry:module-ppopt.geometry.polytope_operations}}\label{\detokenize{ppopt.geometry:ppopt-geometry-polytope-operations-module}}\index{module@\spxentry{module}!ppopt.geometry.polytope\_operations@\spxentry{ppopt.geometry.polytope\_operations}}\index{ppopt.geometry.polytope\_operations@\spxentry{ppopt.geometry.polytope\_operations}!module@\spxentry{module}}\index{find\_extents() (in module ppopt.geometry.polytope\_operations)@\spxentry{find\_extents()}\spxextra{in module ppopt.geometry.polytope\_operations}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.geometry:ppopt.geometry.polytope_operations.find_extents}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.geometry.polytope\_operations.}}\sphinxbfcode{\sphinxupquote{find\_extents}}}{\emph{\DUrole{n}{A}}, \emph{\DUrole{n}{b}}, \emph{\DUrole{n}{d}}, \emph{\DUrole{n}{x}}}{}
\end{fulllineitems}

\index{get\_chebyshev\_information() (in module ppopt.geometry.polytope\_operations)@\spxentry{get\_chebyshev\_information()}\spxextra{in module ppopt.geometry.polytope\_operations}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.geometry:ppopt.geometry.polytope_operations.get_chebyshev_information}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.geometry.polytope\_operations.}}\sphinxbfcode{\sphinxupquote{get\_chebyshev\_information}}}{\emph{\DUrole{n}{region}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.critical_region.CriticalRegion}]{\sphinxcrossref{ppopt.critical\_region.CriticalRegion}}}}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}glpk\textquotesingle{}}}}{}
\end{fulllineitems}

\index{get\_vertices() (in module ppopt.geometry.polytope\_operations)@\spxentry{get\_vertices()}\spxextra{in module ppopt.geometry.polytope\_operations}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.geometry:ppopt.geometry.polytope_operations.get_vertices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.geometry.polytope\_operations.}}\sphinxbfcode{\sphinxupquote{get\_vertices}}}{\emph{\DUrole{n}{region}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.critical_region.CriticalRegion}]{\sphinxcrossref{ppopt.critical\_region.CriticalRegion}}}}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}glpk\textquotesingle{}}}}{}
\sphinxAtStartPar
Generated the vertices of a Critical Region
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{region}} \textendash{} A critical region

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{deterministic\_solver}} \textendash{} The optimization Solver to use

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A numpy array of the vertices of a critical region with vertices stored in rows

\end{description}\end{quote}

\end{fulllineitems}

\index{hit\_and\_run() (in module ppopt.geometry.polytope\_operations)@\spxentry{hit\_and\_run()}\spxextra{in module ppopt.geometry.polytope\_operations}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.geometry:ppopt.geometry.polytope_operations.hit_and_run}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.geometry.polytope\_operations.}}\sphinxbfcode{\sphinxupquote{hit\_and\_run}}}{\emph{\DUrole{n}{p}}, \emph{\DUrole{n}{x\_0}}, \emph{\DUrole{n}{n\_steps}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{10}}}{}
\end{fulllineitems}

\index{sample\_program\_theta\_space() (in module ppopt.geometry.polytope\_operations)@\spxentry{sample\_program\_theta\_space()}\spxextra{in module ppopt.geometry.polytope\_operations}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.geometry:ppopt.geometry.polytope_operations.sample_program_theta_space}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.geometry.polytope\_operations.}}\sphinxbfcode{\sphinxupquote{sample\_program\_theta\_space}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mplp_program.MPLP_Program}]{\sphinxcrossref{ppopt.mplp\_program.MPLP\_Program}}}}}, \emph{\DUrole{n}{num\_samples}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{10}}}{}
\end{fulllineitems}

\index{sample\_region\_convex\_combination() (in module ppopt.geometry.polytope\_operations)@\spxentry{sample\_region\_convex\_combination()}\spxextra{in module ppopt.geometry.polytope\_operations}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.geometry:ppopt.geometry.polytope_operations.sample_region_convex_combination}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.geometry.polytope\_operations.}}\sphinxbfcode{\sphinxupquote{sample\_region\_convex\_combination}}}{\emph{\DUrole{n}{region}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.critical_region.CriticalRegion}]{\sphinxcrossref{ppopt.critical\_region.CriticalRegion}}}}}, \emph{\DUrole{n}{dispersion}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{num\_samples}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{100}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}glpk\textquotesingle{}}}}{}
\sphinxAtStartPar
This is a class to sample a polytopic critical region

\sphinxAtStartPar
Not SUPPORTED YET
:param region:
:param dispersion:
:param num\_samples:
:param deterministic\_solver:
:return:

\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{ppopt.geometry:module-ppopt.geometry}}\label{\detokenize{ppopt.geometry:module-contents}}\index{module@\spxentry{module}!ppopt.geometry@\spxentry{ppopt.geometry}}\index{ppopt.geometry@\spxentry{ppopt.geometry}!module@\spxentry{module}}

\subsubsection{ppopt.mp\_solvers package}
\label{\detokenize{ppopt.mp_solvers:ppopt-mp-solvers-package}}\label{\detokenize{ppopt.mp_solvers::doc}}

\paragraph{Submodules}
\label{\detokenize{ppopt.mp_solvers:submodules}}

\paragraph{ppopt.mp\_solvers.mpqp\_ahmadi module}
\label{\detokenize{ppopt.mp_solvers:module-ppopt.mp_solvers.mpqp_ahmadi}}\label{\detokenize{ppopt.mp_solvers:ppopt-mp-solvers-mpqp-ahmadi-module}}\index{module@\spxentry{module}!ppopt.mp\_solvers.mpqp\_ahmadi@\spxentry{ppopt.mp\_solvers.mpqp\_ahmadi}}\index{ppopt.mp\_solvers.mpqp\_ahmadi@\spxentry{ppopt.mp\_solvers.mpqp\_ahmadi}!module@\spxentry{module}}\index{solve() (in module ppopt.mp\_solvers.mpqp\_ahmadi)@\spxentry{solve()}\spxextra{in module ppopt.mp\_solvers.mpqp\_ahmadi}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_ahmadi.solve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_ahmadi.}}\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This solves a MPQP program with the method proposed by Parisa Ahmadi\sphinxhyphen{}Moshkenani et. al. This algorithm is similar to the graph algorithm implemented by Richard Oberdeik.

\sphinxAtStartPar
The source for the algorithm can be found here. \sphinxurl{https://ieeexplore.ieee.org/document/8252719}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} a MPQP\_Program

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The solution of a MPQP Program

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ppopt.mp\_solvers.mpqp\_combinatorial module}
\label{\detokenize{ppopt.mp_solvers:module-ppopt.mp_solvers.mpqp_combinatorial}}\label{\detokenize{ppopt.mp_solvers:ppopt-mp-solvers-mpqp-combinatorial-module}}\index{module@\spxentry{module}!ppopt.mp\_solvers.mpqp\_combinatorial@\spxentry{ppopt.mp\_solvers.mpqp\_combinatorial}}\index{ppopt.mp\_solvers.mpqp\_combinatorial@\spxentry{ppopt.mp\_solvers.mpqp\_combinatorial}!module@\spxentry{module}}\index{check\_child\_feasibility() (in module ppopt.mp\_solvers.mpqp\_combinatorial)@\spxentry{check\_child\_feasibility()}\spxextra{in module ppopt.mp\_solvers.mpqp\_combinatorial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_combinatorial.check_child_feasibility}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_combinatorial.}}\sphinxbfcode{\sphinxupquote{check\_child\_feasibility}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{set\_list}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{combination\_checker}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solver_utils.CombinationTester}]{\sphinxcrossref{ppopt.mp\_solvers.solver\_utils.CombinationTester}}}}}}{{ $\rightarrow$ List\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
Checks the feasibility of a list of active set combinations, if infeasible add to the combination checker and returns all feasible active set combinations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} An MPQP Program

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{set\_list}} \textendash{} The list of active sets

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{combination\_checker}} \textendash{} The combination checker that prunes

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The list of all feasible active sets

\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (in module ppopt.mp\_solvers.mpqp\_combinatorial)@\spxentry{solve()}\spxextra{in module ppopt.mp\_solvers.mpqp\_combinatorial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_combinatorial.solve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_combinatorial.}}\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}
\sphinxAtStartPar
Solves the MPQP program with a modified algorithm described in Gupta et. al. 2011

\sphinxAtStartPar
The algorithm is described in this paper \sphinxurl{https://www.sciencedirect.com/science/article/pii/S0005109811003190}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} MPQP to be solved

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the solution of the MPQP

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ppopt.mp\_solvers.mpqp\_geometric module}
\label{\detokenize{ppopt.mp_solvers:module-ppopt.mp_solvers.mpqp_geometric}}\label{\detokenize{ppopt.mp_solvers:ppopt-mp-solvers-mpqp-geometric-module}}\index{module@\spxentry{module}!ppopt.mp\_solvers.mpqp\_geometric@\spxentry{ppopt.mp\_solvers.mpqp\_geometric}}\index{ppopt.mp\_solvers.mpqp\_geometric@\spxentry{ppopt.mp\_solvers.mpqp\_geometric}!module@\spxentry{module}}\index{solve() (in module ppopt.mp\_solvers.mpqp\_geometric)@\spxentry{solve()}\spxextra{in module ppopt.mp\_solvers.mpqp\_geometric}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_geometric.solve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_geometric.}}\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{active\_set}\DUrole{o}{=}\DUrole{default_value}{None}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This solved the multiparametric program using the geometric algorithm described in Spjotvold et al.

\sphinxAtStartPar
\sphinxurl{https://www.sciencedirect.com/science/article/pii/S1474667016369154}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} a multiparametric program

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{active\_set}} \textendash{} an initial optimal active set combination

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the solution to the multiparametric optimization problem

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ppopt.mp\_solvers.mpqp\_graph module}
\label{\detokenize{ppopt.mp_solvers:module-ppopt.mp_solvers.mpqp_graph}}\label{\detokenize{ppopt.mp_solvers:ppopt-mp-solvers-mpqp-graph-module}}\index{module@\spxentry{module}!ppopt.mp\_solvers.mpqp\_graph@\spxentry{ppopt.mp\_solvers.mpqp\_graph}}\index{ppopt.mp\_solvers.mpqp\_graph@\spxentry{ppopt.mp\_solvers.mpqp\_graph}!module@\spxentry{module}}\index{graph\_initialization() (in module ppopt.mp\_solvers.mpqp\_graph)@\spxentry{graph\_initialization()}\spxextra{in module ppopt.mp\_solvers.mpqp\_graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_graph.graph_initialization}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_graph.}}\sphinxbfcode{\sphinxupquote{graph\_initialization}}}{\emph{\DUrole{n}{program}}, \emph{\DUrole{n}{initial\_active\_sets}}}{}
\sphinxAtStartPar
Initializes the graph algorithm based on input
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{initial\_active\_sets}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (in module ppopt.mp\_solvers.mpqp\_graph)@\spxentry{solve()}\spxextra{in module ppopt.mp\_solvers.mpqp\_graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_graph.solve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_graph.}}\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{initial\_active\_sets}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ {\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}
\sphinxAtStartPar
Solves the MPQP program with a modified algorithm described in Oberdieck et. al. 2016

\sphinxAtStartPar
url: \sphinxurl{https://www.sciencedirect.com/science/article/pii/S0005109816303971}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} MPQP to be solved

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{initial\_active\_sets}} \textendash{} An initial critical region to start this algorithm with, otherwise one will be found

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the solution of the MPQP

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_no\_murder() (in module ppopt.mp\_solvers.mpqp\_graph)@\spxentry{solve\_no\_murder()}\spxextra{in module ppopt.mp\_solvers.mpqp\_graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_graph.solve_no_murder}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_graph.}}\sphinxbfcode{\sphinxupquote{solve\_no\_murder}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{initial\_active\_sets}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ {\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}
\sphinxAtStartPar
Solves the MPQP program with a modified algorithm described in Oberdieck et. al. 2016

\sphinxAtStartPar
url: \sphinxurl{https://www.sciencedirect.com/science/article/pii/S0005109816303971}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} MPQP to be solved

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{initial\_active\_sets}} \textendash{} An initial critical region to start this algorithm with, otherwise one will be found

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the solution of the MPQP

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ppopt.mp\_solvers.mpqp\_parallel\_geometric module}
\label{\detokenize{ppopt.mp_solvers:module-ppopt.mp_solvers.mpqp_parallel_geometric}}\label{\detokenize{ppopt.mp_solvers:ppopt-mp-solvers-mpqp-parallel-geometric-module}}\index{module@\spxentry{module}!ppopt.mp\_solvers.mpqp\_parallel\_geometric@\spxentry{ppopt.mp\_solvers.mpqp\_parallel\_geometric}}\index{ppopt.mp\_solvers.mpqp\_parallel\_geometric@\spxentry{ppopt.mp\_solvers.mpqp\_parallel\_geometric}!module@\spxentry{module}}\index{full\_process() (in module ppopt.mp\_solvers.mpqp\_parallel\_geometric)@\spxentry{full\_process()}\spxextra{in module ppopt.mp\_solvers.mpqp\_parallel\_geometric}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_parallel_geometric.full_process}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_parallel\_geometric.}}\sphinxbfcode{\sphinxupquote{full\_process}}}{\emph{\DUrole{n}{center}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{norm}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{radius}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{current\_active\_set}}, \emph{\DUrole{n}{indexed\_region\_as}}}{}
\sphinxAtStartPar
This is the function block to be executed in parallel. Takes in a facet. Returns the associated CR on the other side of the facet
if it exists, and all the facets associated with the other side of the
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{center}} \textendash{} Chebychev Center of a Critical Region Facet

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{norm}} \textendash{} Normal of the Facet

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{radius}} \textendash{} Chebychev Radius of the Critical Region Facet

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} the multiparametric program being considered

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{indexed\_region\_as}} \textendash{} set of all critical regions found so far

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{current\_active\_set}} \textendash{} list of the active set that we are stepping out of

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The identified Critical Region on the other side of the facet, and the facets of this critical region or None of nothing

\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (in module ppopt.mp\_solvers.mpqp\_parallel\_geometric)@\spxentry{solve()}\spxextra{in module ppopt.mp\_solvers.mpqp\_parallel\_geometric}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_parallel_geometric.solve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_parallel\_geometric.}}\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{active\_set}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{num\_cores}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This solved the multiparametric program using the geometric algorithm described in Spjotvold et al.

\sphinxAtStartPar
\sphinxurl{https://www.sciencedirect.com/science/article/pii/S1474667016369154}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} a multiparametric program

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{active\_set}} \textendash{} an initial optimal active set combination

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num\_cores}} \textendash{} number of cores to run this calculation on, default of \sphinxhyphen{}1 means use all available cores

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the solution to the multiparametric optimization problem

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ppopt.mp\_solvers.mpqp\_parallel\_geometric\_exp module}
\label{\detokenize{ppopt.mp_solvers:module-ppopt.mp_solvers.mpqp_parallel_geometric_exp}}\label{\detokenize{ppopt.mp_solvers:ppopt-mp-solvers-mpqp-parallel-geometric-exp-module}}\index{module@\spxentry{module}!ppopt.mp\_solvers.mpqp\_parallel\_geometric\_exp@\spxentry{ppopt.mp\_solvers.mpqp\_parallel\_geometric\_exp}}\index{ppopt.mp\_solvers.mpqp\_parallel\_geometric\_exp@\spxentry{ppopt.mp\_solvers.mpqp\_parallel\_geometric\_exp}!module@\spxentry{module}}\index{fathem\_facet\_exp() (in module ppopt.mp\_solvers.mpqp\_parallel\_geometric\_exp)@\spxentry{fathem\_facet\_exp()}\spxextra{in module ppopt.mp\_solvers.mpqp\_parallel\_geometric\_exp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_parallel_geometric_exp.fathem_facet_exp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_parallel\_geometric\_exp.}}\sphinxbfcode{\sphinxupquote{fathem\_facet\_exp}}}{\emph{\DUrole{n}{center}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{normal}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{radius}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{program}}, \emph{\DUrole{n}{current\_active\_set}\DUrole{p}{:} \DUrole{n}{list}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}List\DUrole{p}{{]}}}}
\end{fulllineitems}

\index{fathem\_initial\_active\_sets() (in module ppopt.mp\_solvers.mpqp\_parallel\_geometric\_exp)@\spxentry{fathem\_initial\_active\_sets()}\spxextra{in module ppopt.mp\_solvers.mpqp\_parallel\_geometric\_exp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_parallel_geometric_exp.fathem_initial_active_sets}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_parallel\_geometric\_exp.}}\sphinxbfcode{\sphinxupquote{fathem\_initial\_active\_sets}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{initial\_active\_sets}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{initial\_active\_sets}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{full\_process\_2() (in module ppopt.mp\_solvers.mpqp\_parallel\_geometric\_exp)@\spxentry{full\_process\_2()}\spxextra{in module ppopt.mp\_solvers.mpqp\_parallel\_geometric\_exp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_parallel_geometric_exp.full_process_2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_parallel\_geometric\_exp.}}\sphinxbfcode{\sphinxupquote{full\_process\_2}}}{\emph{\DUrole{n}{program}}, \emph{\DUrole{n}{current\_active\_set}}}{}
\end{fulllineitems}

\index{solve() (in module ppopt.mp\_solvers.mpqp\_parallel\_geometric\_exp)@\spxentry{solve()}\spxextra{in module ppopt.mp\_solvers.mpqp\_parallel\_geometric\_exp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_parallel_geometric_exp.solve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_parallel\_geometric\_exp.}}\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{initial\_active\_sets}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{num\_cores}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This solved the multiparametric program using the geometric algorithm described in Spjotvold et al.

\sphinxAtStartPar
\sphinxurl{https://www.sciencedirect.com/science/article/pii/S1474667016369154}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} a multiparametric program

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{initial\_active\_sets}} \textendash{} a set of optimal active set combinations to initiate the algorithm

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num\_cores}} \textendash{} number of cores to run this calculation on, default of \sphinxhyphen{}1 means use all available cores

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the solution to the multiparametric optimization problem

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial module}
\label{\detokenize{ppopt.mp_solvers:module-ppopt.mp_solvers.mpqp_parrallel_combinatorial}}\label{\detokenize{ppopt.mp_solvers:ppopt-mp-solvers-mpqp-parrallel-combinatorial-module}}\index{module@\spxentry{module}!ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial@\spxentry{ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial}}\index{ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial@\spxentry{ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial}!module@\spxentry{module}}\index{full\_process() (in module ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial)@\spxentry{full\_process()}\spxextra{in module ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_parrallel_combinatorial.full_process}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial.}}\sphinxbfcode{\sphinxupquote{full\_process}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{murder\_list}}, \emph{\DUrole{n}{gen\_children}}}{}
\sphinxAtStartPar
This is the fundamental building block of the parallel combinatorial algorithm, here we branch off of a known feasible active set combinationand then
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} A multiparametric program

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{active\_set}} \textendash{} the active set combination that we are expanding on

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{murder\_list}} \textendash{} the list containing all previously found

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gen\_children}} \textendash{} A boolean flag, that determines if we should generate the children subsets

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a list of the following form {[}Optional{[}CriticalRegion{]}, pruned active set combination,Possibly Feasible Active set combinations{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (in module ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial)@\spxentry{solve()}\spxextra{in module ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_parrallel_combinatorial.solve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial.}}\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{num\_cores}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}}{{ $\rightarrow$ {\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}
\sphinxAtStartPar
Solves the MPQP program with a modified algorithm described in Gupta et. al. 2011

\sphinxAtStartPar
This is the parallel version of the combinatorial.

\sphinxAtStartPar
url: \sphinxurl{https://www.sciencedirect.com/science/article/pii/S0005109811003190}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num\_cores}} \textendash{} Sets the number of cores that are allocated to run this algorithm

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} MPQP to be solved

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the solution of the MPQP

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial\_exp module}
\label{\detokenize{ppopt.mp_solvers:module-ppopt.mp_solvers.mpqp_parrallel_combinatorial_exp}}\label{\detokenize{ppopt.mp_solvers:ppopt-mp-solvers-mpqp-parrallel-combinatorial-exp-module}}\index{module@\spxentry{module}!ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial\_exp@\spxentry{ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial\_exp}}\index{ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial\_exp@\spxentry{ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial\_exp}!module@\spxentry{module}}\index{full\_process() (in module ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial\_exp)@\spxentry{full\_process()}\spxextra{in module ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial\_exp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_parrallel_combinatorial_exp.full_process}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial\_exp.}}\sphinxbfcode{\sphinxupquote{full\_process}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
This is the function block that is executed in parallel. This takes a MPQP program as well as an active set combination, and checks the feasibility of all super sets of cardinality + 1. This is done without using a pruning list as in the otherparallel combinatorial algorithm. This is suited for particularly large problems where an exponential number of prunedactive sets are stored, causing a large memory overhead.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{active\_set}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (in module ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial\_exp)@\spxentry{solve()}\spxextra{in module ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial\_exp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_parrallel_combinatorial_exp.solve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial\_exp.}}\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{num\_cores}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}}{{ $\rightarrow$ {\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}
\sphinxAtStartPar
Solves the MPQP program with a modified algorithm described in Gupta et. al. 2011

\sphinxAtStartPar
This is the parallel version of the combinatorial.

\sphinxAtStartPar
url: \sphinxurl{https://www.sciencedirect.com/science/article/pii/S0005109811003190}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num\_cores}} \textendash{} Sets the number of cores that are allocated to run this algorithm

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} MPQP to be solved

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the solution of the MPQP

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ppopt.mp\_solvers.mpqp\_parrallel\_graph module}
\label{\detokenize{ppopt.mp_solvers:module-ppopt.mp_solvers.mpqp_parrallel_graph}}\label{\detokenize{ppopt.mp_solvers:ppopt-mp-solvers-mpqp-parrallel-graph-module}}\index{module@\spxentry{module}!ppopt.mp\_solvers.mpqp\_parrallel\_graph@\spxentry{ppopt.mp\_solvers.mpqp\_parrallel\_graph}}\index{ppopt.mp\_solvers.mpqp\_parrallel\_graph@\spxentry{ppopt.mp\_solvers.mpqp\_parrallel\_graph}!module@\spxentry{module}}\index{full\_process() (in module ppopt.mp\_solvers.mpqp\_parrallel\_graph)@\spxentry{full\_process()}\spxextra{in module ppopt.mp\_solvers.mpqp\_parrallel\_graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_parrallel_graph.full_process}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_parrallel\_graph.}}\sphinxbfcode{\sphinxupquote{full\_process}}}{\emph{\DUrole{n}{program}}, \emph{\DUrole{n}{candidate}}, \emph{\DUrole{n}{murder\_list}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} A multiparametric program

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} \textendash{} the active set combination that we are expanding on

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{murder\_list}} \textendash{} the list containing all previously found

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a list of the following form {[}List{[}Active Set combinations{]}, active set to prune, Optional{[}CriticalRegion{]}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (in module ppopt.mp\_solvers.mpqp\_parrallel\_graph)@\spxentry{solve()}\spxextra{in module ppopt.mp\_solvers.mpqp\_parrallel\_graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_parrallel_graph.solve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_parrallel\_graph.}}\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{initial\_active\_sets}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{num\_cores}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}}{{ $\rightarrow$ {\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}
\sphinxAtStartPar
Solves the MPQP program with a modified algorithm described in Oberdieck et. al. 2016

\sphinxAtStartPar
url: \sphinxurl{https://www.sciencedirect.com/science/article/pii/S0005109816303971}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} MPQP to be solved

\end{description}\end{quote}

\sphinxAtStartPar
:param initial\_active\_sets:An initial critical region to start this algorithm with, otherwise one will be found
:param num\_cores: number of cores to run this calculation on, default of \sphinxhyphen{}1 means use all available cores
:return: the solution of the MPQP

\end{fulllineitems}

\index{solve\_no\_murder() (in module ppopt.mp\_solvers.mpqp\_parrallel\_graph)@\spxentry{solve\_no\_murder()}\spxextra{in module ppopt.mp\_solvers.mpqp\_parrallel\_graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.mpqp_parrallel_graph.solve_no_murder}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.mpqp\_parrallel\_graph.}}\sphinxbfcode{\sphinxupquote{solve\_no\_murder}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{initial\_active\_sets}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{num\_cores}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}}{{ $\rightarrow$ {\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}
\sphinxAtStartPar
Solves the MPQP program with a modified algorithm described in Oberdieck et. al. 2016

\sphinxAtStartPar
url: \sphinxurl{https://www.sciencedirect.com/science/article/pii/S0005109816303971}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} MPQP to be solved

\end{description}\end{quote}

\sphinxAtStartPar
:param initial\_active\_sets:An initial critical region to start this algorithm with, otherwise one will be found
:param num\_cores: number of cores to run this calculation on, default of \sphinxhyphen{}1 means use all available cores
:return: the solution of the MPQP

\end{fulllineitems}



\paragraph{ppopt.mp\_solvers.solve\_mplp module}
\label{\detokenize{ppopt.mp_solvers:module-ppopt.mp_solvers.solve_mplp}}\label{\detokenize{ppopt.mp_solvers:ppopt-mp-solvers-solve-mplp-module}}\index{module@\spxentry{module}!ppopt.mp\_solvers.solve\_mplp@\spxentry{ppopt.mp\_solvers.solve\_mplp}}\index{ppopt.mp\_solvers.solve\_mplp@\spxentry{ppopt.mp\_solvers.solve\_mplp}!module@\spxentry{module}}\index{mplp\_solver (class in ppopt.mp\_solvers.solve\_mplp)@\spxentry{mplp\_solver}\spxextra{class in ppopt.mp\_solvers.solve\_mplp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solve_mplp.mplp_solver}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.solve\_mplp.}}\sphinxbfcode{\sphinxupquote{mplp\_solver}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{enum.Enum}}

\sphinxAtStartPar
An enumeration.
\index{Dustin (ppopt.mp\_solvers.solve\_mplp.mplp\_solver attribute)@\spxentry{Dustin}\spxextra{ppopt.mp\_solvers.solve\_mplp.mplp\_solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solve_mplp.mplp_solver.Dustin}}\pysigline{\sphinxbfcode{\sphinxupquote{Dustin}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}1\textquotesingle{}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{solve\_mplp() (in module ppopt.mp\_solvers.solve\_mplp)@\spxentry{solve\_mplp()}\spxextra{in module ppopt.mp\_solvers.solve\_mplp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solve_mplp.solve_mplp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.solve\_mplp.}}\sphinxbfcode{\sphinxupquote{solve\_mplp}}}{\emph{problem: ppopt.mplp\_program.MPLP\_Program}, \emph{algorithm: ppopt.mp\_solvers.solve\_mplp.mplp\_solver = \textless{}mplp\_solver.Dustin: \textquotesingle{}1\textquotesingle{}\textgreater{}}}{}
\sphinxAtStartPar
This is the main solver interface for MPLP type problems
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{problem}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{algorithm}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ppopt.mp\_solvers.solve\_mpqp module}
\label{\detokenize{ppopt.mp_solvers:module-ppopt.mp_solvers.solve_mpqp}}\label{\detokenize{ppopt.mp_solvers:ppopt-mp-solvers-solve-mpqp-module}}\index{module@\spxentry{module}!ppopt.mp\_solvers.solve\_mpqp@\spxentry{ppopt.mp\_solvers.solve\_mpqp}}\index{ppopt.mp\_solvers.solve\_mpqp@\spxentry{ppopt.mp\_solvers.solve\_mpqp}!module@\spxentry{module}}\index{filter\_solution() (in module ppopt.mp\_solvers.solve\_mpqp)@\spxentry{filter\_solution()}\spxextra{in module ppopt.mp\_solvers.solve\_mpqp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solve_mpqp.filter_solution}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.solve\_mpqp.}}\sphinxbfcode{\sphinxupquote{filter\_solution}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}
\sphinxAtStartPar
This is a place holder function, in the future this will be used to process and operate on the solution before it is returned to the user
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} a multi parametric solution

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A processed solution

\end{description}\end{quote}

\end{fulllineitems}

\index{mpqp\_algorithm (class in ppopt.mp\_solvers.solve\_mpqp)@\spxentry{mpqp\_algorithm}\spxextra{class in ppopt.mp\_solvers.solve\_mpqp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solve_mpqp.mpqp_algorithm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.solve\_mpqp.}}\sphinxbfcode{\sphinxupquote{mpqp\_algorithm}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{enum.Enum}}

\sphinxAtStartPar
Enum that selects the mpqp algorithm to be used

\sphinxAtStartPar
This is done by passing the argument mpqp\_algorithm.algorithm
\index{combinatorial (ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute)@\spxentry{combinatorial}\spxextra{ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solve_mpqp.mpqp_algorithm.combinatorial}}\pysigline{\sphinxbfcode{\sphinxupquote{combinatorial}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}combinatorial\textquotesingle{}}}}
\end{fulllineitems}

\index{combinatorial\_parallel (ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute)@\spxentry{combinatorial\_parallel}\spxextra{ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solve_mpqp.mpqp_algorithm.combinatorial_parallel}}\pysigline{\sphinxbfcode{\sphinxupquote{combinatorial\_parallel}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}p combinatorial\textquotesingle{}}}}
\end{fulllineitems}

\index{combinatorial\_parallel\_exp (ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute)@\spxentry{combinatorial\_parallel\_exp}\spxextra{ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solve_mpqp.mpqp_algorithm.combinatorial_parallel_exp}}\pysigline{\sphinxbfcode{\sphinxupquote{combinatorial\_parallel\_exp}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}p combinatorial exp\textquotesingle{}}}}
\end{fulllineitems}

\index{geometric (ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute)@\spxentry{geometric}\spxextra{ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solve_mpqp.mpqp_algorithm.geometric}}\pysigline{\sphinxbfcode{\sphinxupquote{geometric}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}geometric\textquotesingle{}}}}
\end{fulllineitems}

\index{geometric\_parallel (ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute)@\spxentry{geometric\_parallel}\spxextra{ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solve_mpqp.mpqp_algorithm.geometric_parallel}}\pysigline{\sphinxbfcode{\sphinxupquote{geometric\_parallel}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}p geometric\textquotesingle{}}}}
\end{fulllineitems}

\index{geometric\_parallel\_exp (ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute)@\spxentry{geometric\_parallel\_exp}\spxextra{ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solve_mpqp.mpqp_algorithm.geometric_parallel_exp}}\pysigline{\sphinxbfcode{\sphinxupquote{geometric\_parallel\_exp}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}p geometric exp\textquotesingle{}}}}
\end{fulllineitems}

\index{graph (ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute)@\spxentry{graph}\spxextra{ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solve_mpqp.mpqp_algorithm.graph}}\pysigline{\sphinxbfcode{\sphinxupquote{graph}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}graph\textquotesingle{}}}}
\end{fulllineitems}

\index{graph\_exp (ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute)@\spxentry{graph\_exp}\spxextra{ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solve_mpqp.mpqp_algorithm.graph_exp}}\pysigline{\sphinxbfcode{\sphinxupquote{graph\_exp}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}graph exp\textquotesingle{}}}}
\end{fulllineitems}

\index{graph\_parallel (ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute)@\spxentry{graph\_parallel}\spxextra{ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solve_mpqp.mpqp_algorithm.graph_parallel}}\pysigline{\sphinxbfcode{\sphinxupquote{graph\_parallel}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}p graph\textquotesingle{}}}}
\end{fulllineitems}

\index{graph\_parallel\_exp (ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute)@\spxentry{graph\_parallel\_exp}\spxextra{ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solve_mpqp.mpqp_algorithm.graph_parallel_exp}}\pysigline{\sphinxbfcode{\sphinxupquote{graph\_parallel\_exp}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}p graph exp\textquotesingle{}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{solve\_mpqp() (in module ppopt.mp\_solvers.solve\_mpqp)@\spxentry{solve\_mpqp()}\spxextra{in module ppopt.mp\_solvers.solve\_mpqp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solve_mpqp.solve_mpqp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.solve\_mpqp.}}\sphinxbfcode{\sphinxupquote{solve\_mpqp}}}{\emph{problem: ppopt.mpqp\_program.MPQP\_Program}, \emph{algorithm: ppopt.mp\_solvers.solve\_mpqp.mpqp\_algorithm = \textless{}mpqp\_algorithm.combinatorial: \textquotesingle{}combinatorial\textquotesingle{}\textgreater{}}}{{ $\rightarrow$ {\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}~\begin{description}
\item[{Takes a mpqp programming problem and solves it in a specified manner, In addition this solves MPLPs. The default}] \leavevmode
\sphinxAtStartPar
solve algorithm is the Combinatorial algorithm by Gupta. et al.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{problem}} \textendash{} Multiparametric Program to be solved

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{algorithm}} \textendash{} Selects the algorithm to be used

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the solution of the MPQP, returns an empty solution if there is not an implemented algorithm

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ppopt.mp\_solvers.solver\_utils module}
\label{\detokenize{ppopt.mp_solvers:module-ppopt.mp_solvers.solver_utils}}\label{\detokenize{ppopt.mp_solvers:ppopt-mp-solvers-solver-utils-module}}\index{module@\spxentry{module}!ppopt.mp\_solvers.solver\_utils@\spxentry{ppopt.mp\_solvers.solver\_utils}}\index{ppopt.mp\_solvers.solver\_utils@\spxentry{ppopt.mp\_solvers.solver\_utils}!module@\spxentry{module}}\index{CombinationTester (class in ppopt.mp\_solvers.solver\_utils)@\spxentry{CombinationTester}\spxextra{class in ppopt.mp\_solvers.solver\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solver_utils.CombinationTester}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.solver\_utils.}}\sphinxbfcode{\sphinxupquote{CombinationTester}}}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
This keeps track of all of the infeasible active set combinations and filters prospective active set combinations
\index{add\_combo() (ppopt.mp\_solvers.solver\_utils.CombinationTester method)@\spxentry{add\_combo()}\spxextra{ppopt.mp\_solvers.solver\_utils.CombinationTester method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solver_utils.CombinationTester.add_combo}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_combo}}}{\emph{\DUrole{n}{active\_set}}}{{ $\rightarrow$ None}}
\end{fulllineitems}

\index{add\_combos() (ppopt.mp\_solvers.solver\_utils.CombinationTester method)@\spxentry{add\_combos()}\spxextra{ppopt.mp\_solvers.solver\_utils.CombinationTester method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solver_utils.CombinationTester.add_combos}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_combos}}}{\emph{\DUrole{n}{set\_list}\DUrole{p}{:} \DUrole{n}{Set\DUrole{p}{{[}}Tuple\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}}}}{{ $\rightarrow$ None}}
\end{fulllineitems}

\index{check() (ppopt.mp\_solvers.solver\_utils.CombinationTester method)@\spxentry{check()}\spxextra{ppopt.mp\_solvers.solver\_utils.CombinationTester method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solver_utils.CombinationTester.check}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check}}}{\emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{Set\DUrole{p}{{[}}int\DUrole{p}{{]}}}}}{{ $\rightarrow$ bool}}
\sphinxAtStartPar
Checks if the provided active set combination is a superset of a previously tested infeasible active set
:param active\_set:
:return: False if it should be culled and not tested any further, True if the set could be feasible

\end{fulllineitems}


\end{fulllineitems}

\index{fathem\_facet() (in module ppopt.mp\_solvers.solver\_utils)@\spxentry{fathem\_facet()}\spxextra{in module ppopt.mp\_solvers.solver\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solver_utils.fathem_facet}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.solver\_utils.}}\sphinxbfcode{\sphinxupquote{fathem\_facet}}}{\emph{\DUrole{n}{center}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{normal}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{radius}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{program}}, \emph{\DUrole{n}{indexed\_region\_as}\DUrole{p}{:} \DUrole{n}{Set}}, \emph{\DUrole{n}{current\_active\_set}\DUrole{p}{:} \DUrole{n}{list}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt:ppopt.critical_region.CriticalRegion}]{\sphinxcrossref{ppopt.critical\_region.CriticalRegion}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This explores the feasible space looking out from a chebychev center of a critical region facet.

\sphinxAtStartPar
Starts from a point with a slight offset from the facet ;= center + D*normal and then check if this is feasible, check if for numerical reasons we accidentally hit ourselves,
check to see if we stepped into a found region, if the active set is full rank we can try to build the critical region, return if full dimensional else double the distance from the facet we are considering
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{center}} \textendash{} chebychev center of

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{normal}} \textendash{} the normal of the polytope facet

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{radius}} \textendash{} chebychev radius of the polytope facet

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} the multiparametric program being considered

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{indexed\_region\_as}} \textendash{} set of all indexed critical region active sets

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{current\_active\_set}} \textendash{} the cir

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a critical region of the other side of the facet if one exists otherwise none

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_optimal\_set() (in module ppopt.mp\_solvers.solver\_utils)@\spxentry{find\_optimal\_set()}\spxextra{in module ppopt.mp\_solvers.solver\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solver_utils.find_optimal_set}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.solver\_utils.}}\sphinxbfcode{\sphinxupquote{find\_optimal\_set}}}{\emph{\DUrole{n}{problem}}}{{ $\rightarrow$ List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is a simple combinatorial algorithm for finding the first optimal active set. This is more or less only here for
implementation completeness as this should never be used in practice.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{problem}} \textendash{} a multiparametric optimization program

\item[{Returns}] \leavevmode
\sphinxAtStartPar
An optimal active set combination

\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_children\_sets() (in module ppopt.mp\_solvers.solver\_utils)@\spxentry{generate\_children\_sets()}\spxextra{in module ppopt.mp\_solvers.solver\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solver_utils.generate_children_sets}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.solver\_utils.}}\sphinxbfcode{\sphinxupquote{generate\_children\_sets}}}{\emph{\DUrole{n}{active\_set}}, \emph{\DUrole{n}{num\_constraints}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{murder\_list}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\end{fulllineitems}

\index{generate\_extra() (in module ppopt.mp\_solvers.solver\_utils)@\spxentry{generate\_extra()}\spxextra{in module ppopt.mp\_solvers.solver\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solver_utils.generate_extra}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.solver\_utils.}}\sphinxbfcode{\sphinxupquote{generate\_extra}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{tuple}}, \emph{\DUrole{n}{expansion\_set}}, \emph{\DUrole{n}{murder\_list}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{attempted}\DUrole{o}{=}\DUrole{default_value}{None}}}{{ $\rightarrow$ list}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{expansion\_set}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{murder\_list}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{attempted}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_reduce() (in module ppopt.mp\_solvers.solver\_utils)@\spxentry{generate\_reduce()}\spxextra{in module ppopt.mp\_solvers.solver\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solver_utils.generate_reduce}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.solver\_utils.}}\sphinxbfcode{\sphinxupquote{generate\_reduce}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{tuple}}, \emph{\DUrole{n}{murder\_list}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{attempted}\DUrole{o}{=}\DUrole{default_value}{None}}}{{ $\rightarrow$ list}}
\end{fulllineitems}

\index{get\_facet\_centers() (in module ppopt.mp\_solvers.solver\_utils)@\spxentry{get\_facet\_centers()}\spxextra{in module ppopt.mp\_solvers.solver\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.mp_solvers:ppopt.mp_solvers.solver_utils.get_facet_centers}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mp\_solvers.solver\_utils.}}\sphinxbfcode{\sphinxupquote{get\_facet\_centers}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ list}}
\sphinxAtStartPar
This takes the polytope P := \{xin R\textasciicircum{}n : Ax \textless{}= b\} and finds all of the chebychev centers and normal vectors of each
facet and the radius
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} The LHS constraint matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} The RHS constraint matrix

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a list with an tuple for each facet in the polytope (chebychev center, facet normal vector, chebychev radius)

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{ppopt.mp_solvers:module-ppopt.mp_solvers}}\label{\detokenize{ppopt.mp_solvers:module-contents}}\index{module@\spxentry{module}!ppopt.mp\_solvers@\spxentry{ppopt.mp\_solvers}}\index{ppopt.mp\_solvers@\spxentry{ppopt.mp\_solvers}!module@\spxentry{module}}

\subsubsection{ppopt.solver\_interface package}
\label{\detokenize{ppopt.solver_interface:ppopt-solver-interface-package}}\label{\detokenize{ppopt.solver_interface::doc}}

\paragraph{Submodules}
\label{\detokenize{ppopt.solver_interface:submodules}}

\paragraph{ppopt.solver\_interface.cvxopt\_interface module}
\label{\detokenize{ppopt.solver_interface:module-ppopt.solver_interface.cvxopt_interface}}\label{\detokenize{ppopt.solver_interface:ppopt-solver-interface-cvxopt-interface-module}}\index{module@\spxentry{module}!ppopt.solver\_interface.cvxopt\_interface@\spxentry{ppopt.solver\_interface.cvxopt\_interface}}\index{ppopt.solver\_interface.cvxopt\_interface@\spxentry{ppopt.solver\_interface.cvxopt\_interface}!module@\spxentry{module}}\index{process\_cvxopt\_solution() (in module ppopt.solver\_interface.cvxopt\_interface)@\spxentry{process\_cvxopt\_solution()}\spxextra{in module ppopt.solver\_interface.cvxopt\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.cvxopt_interface.process_cvxopt_solution}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver\_interface.cvxopt\_interface.}}\sphinxbfcode{\sphinxupquote{process\_cvxopt\_solution}}}{\emph{\DUrole{n}{sol}}, \emph{\DUrole{n}{equality\_constraints}}, \emph{\DUrole{n}{inequality\_constraints}}, \emph{\DUrole{n}{num\_constraints}}, \emph{\DUrole{n}{get\_duals}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\end{fulllineitems}

\index{separate\_constraints() (in module ppopt.solver\_interface.cvxopt\_interface)@\spxentry{separate\_constraints()}\spxextra{in module ppopt.solver\_interface.cvxopt\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.cvxopt_interface.separate_constraints}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver\_interface.cvxopt\_interface.}}\sphinxbfcode{\sphinxupquote{separate\_constraints}}}{\emph{\DUrole{n}{A}}, \emph{\DUrole{n}{b}}, \emph{\DUrole{n}{equality\_constraints}}, \emph{\DUrole{n}{ineq}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ineq}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_fully\_constraints() (in module ppopt.solver\_interface.cvxopt\_interface)@\spxentry{solve\_fully\_constraints()}\spxextra{in module ppopt.solver\_interface.cvxopt\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.cvxopt_interface.solve_fully_constraints}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver\_interface.cvxopt\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_fully\_constraints}}}{\emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This solves a fully constrained linear system by directly solving the linear system. This is NOT complete
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A SolverOutput Object

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_lp\_cvxopt() (in module ppopt.solver\_interface.cvxopt\_interface)@\spxentry{solve\_lp\_cvxopt()}\spxextra{in module ppopt.solver\_interface.cvxopt\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.cvxopt_interface.solve_lp_cvxopt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver\_interface.cvxopt\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_lp\_cvxopt}}}{\emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{cvx\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}glpk\textquotesingle{}}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving linear programs with cvxopt, This is the preferred Solver as it has the lowest interface cost of all of the other solvers
\begin{description}
\item[{The Mixed Integer Linear program programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{x\} c\textasciicircum{}Tx
\begin{description}
\item[{s.t.    A{[}x{]} \textless{}= b}] \leavevmode
\sphinxAtStartPar
Aeq*{[}x{]} = beq

\sphinxAtStartPar
x is the parameter vector of real values

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cvx\_solver}} \textendash{} selects the cvxopt Solver, default is glpk

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A SolverOutput Object

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_qp\_cvxopt() (in module ppopt.solver\_interface.cvxopt\_interface)@\spxentry{solve\_qp\_cvxopt()}\spxextra{in module ppopt.solver\_interface.cvxopt\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.cvxopt_interface.solve_qp_cvxopt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver\_interface.cvxopt\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_qp\_cvxopt}}}{\emph{\DUrole{n}{Q}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{cvx\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}quadprog\textquotesingle{}}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\end{fulllineitems}



\paragraph{ppopt.solver\_interface.gurobi\_solver\_interface module}
\label{\detokenize{ppopt.solver_interface:module-ppopt.solver_interface.gurobi_solver_interface}}\label{\detokenize{ppopt.solver_interface:ppopt-solver-interface-gurobi-solver-interface-module}}\index{module@\spxentry{module}!ppopt.solver\_interface.gurobi\_solver\_interface@\spxentry{ppopt.solver\_interface.gurobi\_solver\_interface}}\index{ppopt.solver\_interface.gurobi\_solver\_interface@\spxentry{ppopt.solver\_interface.gurobi\_solver\_interface}!module@\spxentry{module}}\index{solve\_lp\_gurobi() (in module ppopt.solver\_interface.gurobi\_solver\_interface)@\spxentry{solve\_lp\_gurobi()}\spxextra{in module ppopt.solver\_interface.gurobi\_solver\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.gurobi_solver_interface.solve_lp_gurobi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver\_interface.gurobi\_solver\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_lp\_gurobi}}}{\emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving mixed integer linear programs with gruobi, This is feed directly into the
MIQP Solver that is defined in the same file.
\begin{description}
\item[{The Mixed Integer Linear program programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{xy\} c\textasciicircum{}T*{[}xy{]}
\begin{description}
\item[{s.t.    A{[}xy{]} \textless{}= b}] \leavevmode
\sphinxAtStartPar
Aeq*{[}xy{]} = beq

\sphinxAtStartPar
xy is the parameter vector of mixed real and binary inputs

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A SolverOutput Object

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_milp\_gurobi() (in module ppopt.solver\_interface.gurobi\_solver\_interface)@\spxentry{solve\_milp\_gurobi()}\spxextra{in module ppopt.solver\_interface.gurobi\_solver\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.gurobi_solver_interface.solve_milp_gurobi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver\_interface.gurobi\_solver\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_milp\_gurobi}}}{\emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{bin\_vars}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{o}{=}\DUrole{default_value}{True}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving mixed integer linear programs with gruobi, This is feed directly into the
MIQP Solver that is defined in the same file.
\begin{description}
\item[{The Mixed Integer Linear program programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{xy\} c\textasciicircum{}T*{[}xy{]}
\begin{description}
\item[{s.t.   A{[}xy{]} \textless{}= b}] \leavevmode
\sphinxAtStartPar
Aeq*{[}xy{]} = beq
\begin{quote}

\sphinxAtStartPar
xy is the parameter vector of mixed real and binary inputs
\end{quote}

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_vars}} \textendash{} List of binary variable indices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True (false for all mixed integer models)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A SolverOutput Object

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_miqp\_gurobi() (in module ppopt.solver\_interface.gurobi\_solver\_interface)@\spxentry{solve\_miqp\_gurobi()}\spxextra{in module ppopt.solver\_interface.gurobi\_solver\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.gurobi_solver_interface.solve_miqp_gurobi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver\_interface.gurobi\_solver\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_miqp\_gurobi}}}{\emph{\DUrole{n}{Q}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{bin\_vars}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving mixed integer quadratic programs with gruobi

\sphinxAtStartPar
The Mixed Integer Quadratic program programming problem
min\_\{xy\} 1/2 {[}xy{]}\textasciicircum{}T*Q*{[}xy{]} + c\textasciicircum{}T*{[}xy{]}
\begin{description}
\item[{s.t.    A{[}xy{]} \textless{}= b}] \leavevmode
\sphinxAtStartPar
Aeq*{[}xy{]} = beq

\sphinxAtStartPar
xy is the parameter vector of mixed real and binary inputs

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Q}} \textendash{} Square matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_vars}} \textendash{} List of binary variable indices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True (false for all mixed integer models)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A dictionary of the Solver outputs, or none if infeasible or unbounded. n output{[}‘sol’{]} = primal

\end{description}\end{quote}

\sphinxAtStartPar
variables, output{[}‘dual’{]} = dual variables, output{[}‘obj’{]} = objective value, output{[}‘const’{]} = slacks,
output{[}‘active’{]} = active constraints.

\end{fulllineitems}

\index{solve\_qp\_gurobi() (in module ppopt.solver\_interface.gurobi\_solver\_interface)@\spxentry{solve\_qp\_gurobi()}\spxextra{in module ppopt.solver\_interface.gurobi\_solver\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.gurobi_solver_interface.solve_qp_gurobi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver\_interface.gurobi\_solver\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_qp\_gurobi}}}{\emph{\DUrole{n}{Q}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{o}{=}\DUrole{default_value}{True}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving mixed integer quadratic programs with gruobi
\begin{description}
\item[{The Mixed Integer Quadratic program programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{xy\} 1/2 {[}xy{]}\textasciicircum{}T*Q*{[}xy{]} + c\textasciicircum{}T*{[}xy{]}
\begin{description}
\item[{s.t.   A{[}xy{]} \textless{}= b}] \leavevmode
\sphinxAtStartPar
Aeq*{[}xy{]} = beq

\sphinxAtStartPar
xy is the parameter vector of mixed real and binary inputs

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Q}} \textendash{} Square matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True (false for all mixed integer models)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A SolverOutput Object

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ppopt.solver\_interface.quad\_prog\_interface module}
\label{\detokenize{ppopt.solver_interface:module-ppopt.solver_interface.quad_prog_interface}}\label{\detokenize{ppopt.solver_interface:ppopt-solver-interface-quad-prog-interface-module}}\index{module@\spxentry{module}!ppopt.solver\_interface.quad\_prog\_interface@\spxentry{ppopt.solver\_interface.quad\_prog\_interface}}\index{ppopt.solver\_interface.quad\_prog\_interface@\spxentry{ppopt.solver\_interface.quad\_prog\_interface}!module@\spxentry{module}}\index{solve\_qp\_quadprog() (in module ppopt.solver\_interface.quad\_prog\_interface)@\spxentry{solve\_qp\_quadprog()}\spxextra{in module ppopt.solver\_interface.quad\_prog\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.quad_prog_interface.solve_qp_quadprog}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver\_interface.quad\_prog\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_qp\_quadprog}}}{\emph{\DUrole{n}{Q}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
Calls Quadprog to solve the following optimization problem
\begin{description}
\item[{The Quadratic programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{x\} 1/2 x\textasciicircum{}T@Q@x + c\textasciicircum{}T@x
\begin{description}
\item[{s.t.   A@x \textless{}= b}] \leavevmode
\sphinxAtStartPar
A\_eq@x = beq

\sphinxAtStartPar
x in R\textasciicircum{}n

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Q}} \textendash{} Square matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True (false for all mixed integer models)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A SolverOutput object if optima found, otherwise None.

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ppopt.solver\_interface.solver\_interface module}
\label{\detokenize{ppopt.solver_interface:module-ppopt.solver_interface.solver_interface}}\label{\detokenize{ppopt.solver_interface:ppopt-solver-interface-solver-interface-module}}\index{module@\spxentry{module}!ppopt.solver\_interface.solver\_interface@\spxentry{ppopt.solver\_interface.solver\_interface}}\index{ppopt.solver\_interface.solver\_interface@\spxentry{ppopt.solver\_interface.solver\_interface}!module@\spxentry{module}}\index{solve\_lp() (in module ppopt.solver\_interface.solver\_interface)@\spxentry{solve\_lp()}\spxextra{in module ppopt.solver\_interface.solver\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface.solve_lp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver\_interface.solver\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_lp}}}{\emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}glpk\textquotesingle{}}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving linear programs
\begin{description}
\item[{The Linear programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{xy\} c\textasciicircum{}T@{[}xy{]}
\begin{description}
\item[{s.t.   A@x \textless{}= b}] \leavevmode
\sphinxAtStartPar
A\_eq@x = beq

\sphinxAtStartPar
x in R\textasciicircum{}n

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True (false for all mixed integer models)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{deterministic\_solver}} \textendash{} The underlying Solver to use, eg. gurobi, ect

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A SolverOutput object if optima found, otherwise None.

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_milp() (in module ppopt.solver\_interface.solver\_interface)@\spxentry{solve\_milp()}\spxextra{in module ppopt.solver\_interface.solver\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface.solve_milp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver\_interface.solver\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_milp}}}{\emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{bin\_vars}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}gurobi\textquotesingle{}}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving mixed integer linear programs
\begin{description}
\item[{The Mixed Integer Linear programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{xy\} c\textasciicircum{}T*{[}xy{]}
\begin{description}
\item[{s.t.   A{[}xy{]} \textless{}= b}] \leavevmode
\sphinxAtStartPar
Aeq*{[}xy{]} = beq

\sphinxAtStartPar
xy is the parameter vector of mixed real and binary inputs
x in R\textasciicircum{}n
y in \{0, 1\}\textasciicircum{}m

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_vars}} \textendash{} List of binary variable indices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True (false for all mixed integer models)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{deterministic\_solver}} \textendash{} The underlying Solver to use, eg. gurobi, ect

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A dictionary of the Solver outputs, or none if infeasible or unbounded. output{[}‘sol’{]} = primal variables, output{[}‘dual’{]} = dual variables, output{[}‘obj’{]} = objective value, output{[}‘const’{]} = slacks, output{[}‘active’{]} = active constraints.

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_miqp() (in module ppopt.solver\_interface.solver\_interface)@\spxentry{solve\_miqp()}\spxextra{in module ppopt.solver\_interface.solver\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface.solve_miqp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver\_interface.solver\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_miqp}}}{\emph{\DUrole{n}{Q}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{bin\_vars}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}gurobi\textquotesingle{}}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving mixed integer quadratic programs
\begin{description}
\item[{The Mixed Integer Quadratic program programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{xy\} 1/2 {[}xy{]}\textasciicircum{}T@Q@{[}xy{]} + c\textasciicircum{}T@{[}xy{]}
\begin{description}
\item[{s.t.   A@{[}xy{]} \textless{}= b}] \leavevmode
\sphinxAtStartPar
A\_eq@{[}xy{]} = beq

\sphinxAtStartPar
xy is the parameter vector of mixed real and binary inputs
x in R\textasciicircum{}n
y in \{0, 1\}\textasciicircum{}m

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Q}} \textendash{} Square matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_vars}} \textendash{} List of binary variable indices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True (false for all mixed integer models)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{deterministic\_solver}} \textendash{} The underlying Solver to use, eg. gurobi, ect

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A SolverOutput object if optima found, otherwise None.

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_qp() (in module ppopt.solver\_interface.solver\_interface)@\spxentry{solve\_qp()}\spxextra{in module ppopt.solver\_interface.solver\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface.solve_qp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver\_interface.solver\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_qp}}}{\emph{\DUrole{n}{Q}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}gurobi\textquotesingle{}}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving quadratic programs
\begin{description}
\item[{The Quadratic programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{x\} 1/2 x\textasciicircum{}T@Q@x + c\textasciicircum{}T@x
\begin{description}
\item[{s.t.   A@x \textless{}= b}] \leavevmode
\sphinxAtStartPar
A\_eq@x = beq

\sphinxAtStartPar
x in R\textasciicircum{}n

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Q}} \textendash{} Square matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True (false for all mixed integer models)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{deterministic\_solver}} \textendash{} The underlying Solver to use, eg. gurobi, ect

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A SolverOutput object if optima found, otherwise None.

\end{description}\end{quote}

\end{fulllineitems}

\index{solver\_not\_supported() (in module ppopt.solver\_interface.solver\_interface)@\spxentry{solver\_not\_supported()}\spxextra{in module ppopt.solver\_interface.solver\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface.solver_not_supported}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver\_interface.solver\_interface.}}\sphinxbfcode{\sphinxupquote{solver\_not\_supported}}}{\emph{\DUrole{n}{solver\_name}\DUrole{p}{:} \DUrole{n}{str}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
This is an internal method that throws an error and prompts the user when they use an unsupported Solver

\end{fulllineitems}



\paragraph{ppopt.solver\_interface.solver\_interface\_utils module}
\label{\detokenize{ppopt.solver_interface:module-ppopt.solver_interface.solver_interface_utils}}\label{\detokenize{ppopt.solver_interface:ppopt-solver-interface-solver-interface-utils-module}}\index{module@\spxentry{module}!ppopt.solver\_interface.solver\_interface\_utils@\spxentry{ppopt.solver\_interface.solver\_interface\_utils}}\index{ppopt.solver\_interface.solver\_interface\_utils@\spxentry{ppopt.solver\_interface.solver\_interface\_utils}!module@\spxentry{module}}\index{SolverOutput (class in ppopt.solver\_interface.solver\_interface\_utils)@\spxentry{SolverOutput}\spxextra{class in ppopt.solver\_interface.solver\_interface\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ppopt.solver\_interface.solver\_interface\_utils.}}\sphinxbfcode{\sphinxupquote{SolverOutput}}}{\emph{\DUrole{n}{obj}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{sol}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{slack}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{dual}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
This is the generic Solver information object. This will be the general return object from all of the back end solvers. This was done to remove the need for the user to specialize IO for any particular Solver. It containsall of the information you would need for the optimization solution including, optimal value, optimal solution, the active set, the value of the slack variables and the largange multipliers associated with every constraint (these are listed)
\begin{quote}

\sphinxAtStartPar
as the dual variables.
\end{quote}

\sphinxAtStartPar
Members:
obj: objective value of the optimal solution

\sphinxAtStartPar
sol: x*, numpy array

\sphinxAtStartPar
Optional Parameters \sphinxhyphen{}\textgreater{} None or numpy.ndarray type

\sphinxAtStartPar
slack: the slacks associated with every constraint

\sphinxAtStartPar
equality\_indices: the active set of the solution, including strongly and weakly active constraints

\sphinxAtStartPar
dual: the lagrange multipliers associated with the problem
\index{active\_set (ppopt.solver\_interface.solver\_interface\_utils.SolverOutput attribute)@\spxentry{active\_set}\spxextra{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput.active_set}}\pysigline{\sphinxbfcode{\sphinxupquote{active\_set}}\sphinxbfcode{\sphinxupquote{: Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{dual (ppopt.solver\_interface.solver\_interface\_utils.SolverOutput attribute)@\spxentry{dual}\spxextra{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput.dual}}\pysigline{\sphinxbfcode{\sphinxupquote{dual}}\sphinxbfcode{\sphinxupquote{: Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{obj (ppopt.solver\_interface.solver\_interface\_utils.SolverOutput attribute)@\spxentry{obj}\spxextra{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput.obj}}\pysigline{\sphinxbfcode{\sphinxupquote{obj}}\sphinxbfcode{\sphinxupquote{: float}}}
\end{fulllineitems}

\index{slack (ppopt.solver\_interface.solver\_interface\_utils.SolverOutput attribute)@\spxentry{slack}\spxextra{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput.slack}}\pysigline{\sphinxbfcode{\sphinxupquote{slack}}\sphinxbfcode{\sphinxupquote{: Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{sol (ppopt.solver\_interface.solver\_interface\_utils.SolverOutput attribute)@\spxentry{sol}\spxextra{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput.sol}}\pysigline{\sphinxbfcode{\sphinxupquote{sol}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}


\end{fulllineitems}

\index{get\_program\_parameters() (in module ppopt.solver\_interface.solver\_interface\_utils)@\spxentry{get\_program\_parameters()}\spxextra{in module ppopt.solver\_interface.solver\_interface\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.get_program_parameters}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver\_interface.solver\_interface\_utils.}}\sphinxbfcode{\sphinxupquote{get\_program\_parameters}}}{\emph{\DUrole{n}{Q}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
Given a set of possibly None optimization parameters determine the number of variables and constraints

\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{ppopt.solver_interface:module-ppopt.solver_interface}}\label{\detokenize{ppopt.solver_interface:module-contents}}\index{module@\spxentry{module}!ppopt.solver\_interface@\spxentry{ppopt.solver\_interface}}\index{ppopt.solver\_interface@\spxentry{ppopt.solver\_interface}!module@\spxentry{module}}

\subsubsection{ppopt.upop package}
\label{\detokenize{ppopt.upop:ppopt-upop-package}}\label{\detokenize{ppopt.upop::doc}}

\paragraph{Submodules}
\label{\detokenize{ppopt.upop:submodules}}

\paragraph{ppopt.upop.language\_generation module}
\label{\detokenize{ppopt.upop:module-ppopt.upop.language_generation}}\label{\detokenize{ppopt.upop:ppopt-upop-language-generation-module}}\index{module@\spxentry{module}!ppopt.upop.language\_generation@\spxentry{ppopt.upop.language\_generation}}\index{ppopt.upop.language\_generation@\spxentry{ppopt.upop.language\_generation}!module@\spxentry{module}}\index{gen\_array() (in module ppopt.upop.language\_generation)@\spxentry{gen\_array()}\spxextra{in module ppopt.upop.language\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.language_generation.gen_array}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.language\_generation.}}\sphinxbfcode{\sphinxupquote{gen\_array}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{vartype}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{(\textquotesingle{}const\textquotesingle{})}}, \emph{\DUrole{n}{lang}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}cpp\textquotesingle{}}}}{{ $\rightarrow$ str}}
\end{fulllineitems}

\index{gen\_cpp\_array() (in module ppopt.upop.language\_generation)@\spxentry{gen\_cpp\_array()}\spxextra{in module ppopt.upop.language\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.language_generation.gen_cpp_array}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.language\_generation.}}\sphinxbfcode{\sphinxupquote{gen\_cpp\_array}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{vartype}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{options}\DUrole{p}{:} \DUrole{n}{list} \DUrole{o}{=} \DUrole{default_value}{(\textquotesingle{}const\textquotesingle{})}}}{{ $\rightarrow$ str}}
\sphinxAtStartPar
Generates a static C++ array from the provided data in the following format

\sphinxAtStartPar
vartype name{[}size{]} = \{data\};
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{vartype}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{options}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{gen\_cpp\_variable() (in module ppopt.upop.language\_generation)@\spxentry{gen\_cpp\_variable()}\spxextra{in module ppopt.upop.language\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.language_generation.gen_cpp_variable}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.language\_generation.}}\sphinxbfcode{\sphinxupquote{gen\_cpp\_variable}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{vartype}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{options}\DUrole{p}{:} \DUrole{n}{list} \DUrole{o}{=} \DUrole{default_value}{(\textquotesingle{}const\textquotesingle{})}}}{{ $\rightarrow$ str}}
\end{fulllineitems}

\index{gen\_js\_array() (in module ppopt.upop.language\_generation)@\spxentry{gen\_js\_array()}\spxextra{in module ppopt.upop.language\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.language_generation.gen_js_array}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.language\_generation.}}\sphinxbfcode{\sphinxupquote{gen\_js\_array}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{vartype}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{options}\DUrole{p}{:} \DUrole{n}{list} \DUrole{o}{=} \DUrole{default_value}{(\textquotesingle{}const\textquotesingle{})}}}{{ $\rightarrow$ str}}
\end{fulllineitems}

\index{gen\_js\_variable() (in module ppopt.upop.language\_generation)@\spxentry{gen\_js\_variable()}\spxextra{in module ppopt.upop.language\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.language_generation.gen_js_variable}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.language\_generation.}}\sphinxbfcode{\sphinxupquote{gen\_js\_variable}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{vartype}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{options}\DUrole{p}{:} \DUrole{n}{list} \DUrole{o}{=} \DUrole{default_value}{(\textquotesingle{}const\textquotesingle{})}}}{{ $\rightarrow$ str}}
\end{fulllineitems}

\index{gen\_python\_array() (in module ppopt.upop.language\_generation)@\spxentry{gen\_python\_array()}\spxextra{in module ppopt.upop.language\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.language_generation.gen_python_array}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.language\_generation.}}\sphinxbfcode{\sphinxupquote{gen\_python\_array}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{vartype}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{options}\DUrole{p}{:} \DUrole{n}{list} \DUrole{o}{=} \DUrole{default_value}{(\textquotesingle{}const\textquotesingle{})}}}{{ $\rightarrow$ str}}
\end{fulllineitems}

\index{gen\_python\_variable() (in module ppopt.upop.language\_generation)@\spxentry{gen\_python\_variable()}\spxextra{in module ppopt.upop.language\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.language_generation.gen_python_variable}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.language\_generation.}}\sphinxbfcode{\sphinxupquote{gen\_python\_variable}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{vartype}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{options}\DUrole{p}{:} \DUrole{n}{list} \DUrole{o}{=} \DUrole{default_value}{(\textquotesingle{}const\textquotesingle{})}}}{{ $\rightarrow$ str}}
\end{fulllineitems}

\index{gen\_variable() (in module ppopt.upop.language\_generation)@\spxentry{gen\_variable()}\spxextra{in module ppopt.upop.language\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.language_generation.gen_variable}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.language\_generation.}}\sphinxbfcode{\sphinxupquote{gen\_variable}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{vartype}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{(\textquotesingle{}const\textquotesingle{})}}, \emph{\DUrole{n}{lang}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}cpp\textquotesingle{}}}}{{ $\rightarrow$ str}}
\end{fulllineitems}



\paragraph{ppopt.upop.linear\_code\_gen module}
\label{\detokenize{ppopt.upop:module-ppopt.upop.linear_code_gen}}\label{\detokenize{ppopt.upop:ppopt-upop-linear-code-gen-module}}\index{module@\spxentry{module}!ppopt.upop.linear\_code\_gen@\spxentry{ppopt.upop.linear\_code\_gen}}\index{ppopt.upop.linear\_code\_gen@\spxentry{ppopt.upop.linear\_code\_gen}!module@\spxentry{module}}\index{generate\_code\_cpp() (in module ppopt.upop.linear\_code\_gen)@\spxentry{generate\_code\_cpp()}\spxextra{in module ppopt.upop.linear\_code\_gen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.linear_code_gen.generate_code_cpp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.linear\_code\_gen.}}\sphinxbfcode{\sphinxupquote{generate\_code\_cpp}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}, \emph{\DUrole{n}{float\_type}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}float\textquotesingle{}}}}{{ $\rightarrow$ str}}
\sphinxAtStartPar
Generates C++17 code for point location and function evaluation on microcontrollers

\sphinxAtStartPar
WARNING: This breaks down at high dimensions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} a solution to a MPLP or MPQP solution

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{float\_type}} \textendash{} the type of C++ float to export, e.g. ‘double’ or ‘float’

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
List of the strings of the C++17 datafiles that integrate with uPOP

\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_code\_js() (in module ppopt.upop.linear\_code\_gen)@\spxentry{generate\_code\_js()}\spxextra{in module ppopt.upop.linear\_code\_gen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.linear_code_gen.generate_code_js}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.linear\_code\_gen.}}\sphinxbfcode{\sphinxupquote{generate\_code\_js}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}}{{ $\rightarrow$ List\DUrole{p}{{[}}str\DUrole{p}{{]}}}}
\sphinxAtStartPar
Generates Javascript code for point location and function evaluation for Scripting Engines and IOT servers

\sphinxAtStartPar
This is direct enumeration, and it is
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} a solution to a MPLP or MPQP solution

\item[{Returns}] \leavevmode
\sphinxAtStartPar
List of the strings of the C++17 datafiles that integrate with uPOP

\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_code\_matlab() (in module ppopt.upop.linear\_code\_gen)@\spxentry{generate\_code\_matlab()}\spxextra{in module ppopt.upop.linear\_code\_gen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.linear_code_gen.generate_code_matlab}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.linear\_code\_gen.}}\sphinxbfcode{\sphinxupquote{generate\_code\_matlab}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}, \emph{\DUrole{n}{path}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
This code gen does not bother with memory compression as it is running in the matlab environment and takes \textasciitilde{}1 gb to run anyways
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} File export path, if not specified will save in current working directory

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ppopt.upop.point\_location module}
\label{\detokenize{ppopt.upop:module-ppopt.upop.point_location}}\label{\detokenize{ppopt.upop:ppopt-upop-point-location-module}}\index{module@\spxentry{module}!ppopt.upop.point\_location@\spxentry{ppopt.upop.point\_location}}\index{ppopt.upop.point\_location@\spxentry{ppopt.upop.point\_location}!module@\spxentry{module}}\index{PointLocation (class in ppopt.upop.point\_location)@\spxentry{PointLocation}\spxextra{class in ppopt.upop.point\_location}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.point_location.PointLocation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ppopt.upop.point\_location.}}\sphinxbfcode{\sphinxupquote{PointLocation}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}
\index{evaluate() (ppopt.upop.point\_location.PointLocation method)@\spxentry{evaluate()}\spxextra{ppopt.upop.point\_location.PointLocation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.point_location.PointLocation.evaluate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{evaluate}}}{\emph{\DUrole{n}{theta}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Evaluates the value of x(theta), of the
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{theta}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{is\_inside() (ppopt.upop.point\_location.PointLocation method)@\spxentry{is\_inside()}\spxextra{ppopt.upop.point\_location.PointLocation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.point_location.PointLocation.is_inside}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_inside}}}{\emph{\DUrole{n}{theta}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ bool}}~\begin{quote}

\sphinxAtStartPar
Determines if the theta point in inside of the feasible space
\begin{quote}\begin{description}
\item[{param theta}] \leavevmode
\sphinxAtStartPar
A point in the theta space

\item[{return}] \leavevmode
\sphinxAtStartPar
True, if theta in region

\end{description}\end{quote}
\end{quote}

\sphinxAtStartPar
False, if theta not in region

\end{fulllineitems}

\index{locate() (ppopt.upop.point\_location.PointLocation method)@\spxentry{locate()}\spxextra{ppopt.upop.point\_location.PointLocation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.point_location.PointLocation.locate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{locate}}}{\emph{\DUrole{n}{theta}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ int}}
\sphinxAtStartPar
Finds the index of the critical region that theta is inside
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{theta}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{ppopt.upop.ucontroller module}
\label{\detokenize{ppopt.upop:module-ppopt.upop.ucontroller}}\label{\detokenize{ppopt.upop:ppopt-upop-ucontroller-module}}\index{module@\spxentry{module}!ppopt.upop.ucontroller@\spxentry{ppopt.upop.ucontroller}}\index{ppopt.upop.ucontroller@\spxentry{ppopt.upop.ucontroller}!module@\spxentry{module}}\index{BVH (class in ppopt.upop.ucontroller)@\spxentry{BVH}\spxextra{class in ppopt.upop.ucontroller}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.ucontroller.BVH}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ppopt.upop.ucontroller.}}\sphinxbfcode{\sphinxupquote{BVH}}}{\emph{\DUrole{n}{parent}}, \emph{\DUrole{n}{fundamental\_list}}, \emph{\DUrole{n}{region\_list}}, \emph{\DUrole{n}{depth}}, \emph{\DUrole{n}{index}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\end{fulllineitems}

\index{classify\_polytope() (in module ppopt.upop.ucontroller)@\spxentry{classify\_polytope()}\spxextra{in module ppopt.upop.ucontroller}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.ucontroller.classify_polytope}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.ucontroller.}}\sphinxbfcode{\sphinxupquote{classify\_polytope}}}{\emph{\DUrole{n}{region}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.critical_region.CriticalRegion}]{\sphinxcrossref{ppopt.critical\_region.CriticalRegion}}}}}, \emph{\DUrole{n}{hyper\_plane}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ int}}
\sphinxAtStartPar
We are going to classify the polytopic critical region by solving 2 LPS

\sphinxAtStartPar
max ||\textless{}x,A\textgreater{}||\sphinxhyphen{}d for x in Critical region

\sphinxAtStartPar
min ||\textless{}x,A\textgreater{}||\sphinxhyphen{}d for x in Critical region

\sphinxAtStartPar
The result of the objective function will tell us the side of the hyper plane the point is on
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{region}} \textendash{} Critical region

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hyper\_plane}} \textendash{} A fundamental hyperplane

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxhyphen{}1 if completely not in support, 0 if intersected, 1 if completely in support

\end{description}\end{quote}

\end{fulllineitems}

\index{determine\_hyperplane() (in module ppopt.upop.ucontroller)@\spxentry{determine\_hyperplane()}\spxextra{in module ppopt.upop.ucontroller}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.ucontroller.determine_hyperplane}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.ucontroller.}}\sphinxbfcode{\sphinxupquote{determine\_hyperplane}}}{\emph{\DUrole{n}{regions}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt:ppopt.critical_region.CriticalRegion}]{\sphinxcrossref{ppopt.critical\_region.CriticalRegion}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{hyper\_planes}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{}
\sphinxAtStartPar
Finds the ‘best’ splitting hyper plane for this task

\sphinxAtStartPar
In this case best means minimizing the number of intersected regions while also maximizing the difference between supported and not supported regions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{regions}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hyper\_planes}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
{[}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_code() (in module ppopt.upop.ucontroller)@\spxentry{generate\_code()}\spxextra{in module ppopt.upop.ucontroller}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.ucontroller.generate_code}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.ucontroller.}}\sphinxbfcode{\sphinxupquote{generate\_code}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}}{{ $\rightarrow$ List\DUrole{p}{{[}}str\DUrole{p}{{]}}}}
\sphinxAtStartPar
Generates C++17 code for point location and function evaluation on microcontrollers

\sphinxAtStartPar
This forms a BVH to accelerate solution times

\sphinxAtStartPar
WARNING: This breaks down at high dimensions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} a solution to a MPLP or MPQP solution

\item[{Returns}] \leavevmode
\sphinxAtStartPar
List of the strings of the C++17 datafiles that integrate with uPOP

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ppopt.upop.upop\_utils module}
\label{\detokenize{ppopt.upop:module-ppopt.upop.upop_utils}}\label{\detokenize{ppopt.upop:ppopt-upop-upop-utils-module}}\index{module@\spxentry{module}!ppopt.upop.upop\_utils@\spxentry{ppopt.upop.upop\_utils}}\index{ppopt.upop.upop\_utils@\spxentry{ppopt.upop.upop\_utils}!module@\spxentry{module}}\index{find\_unique\_hyperplanes() (in module ppopt.upop.upop\_utils)@\spxentry{find\_unique\_hyperplanes()}\spxextra{in module ppopt.upop.upop\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.upop_utils.find_unique_hyperplanes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.upop\_utils.}}\sphinxbfcode{\sphinxupquote{find\_unique\_hyperplanes}}}{\emph{\DUrole{n}{overall}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ Tuple\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
Generates the list of indices of the fundamental hyperplanes of the solution, as well as the indices of the associated hyperplanes from the original solution and the parity of the constraint

\sphinxAtStartPar
This is linear w.r.t. number of hyper planes and is quite quick \textasciitilde{}25 ns per constraint in the solution

\sphinxAtStartPar
It first creates approximate(near exact) integer representations for each constraint for each region in the solution

\sphinxAtStartPar
This approximation step is justified in that it will find equality between 2 constraints if the L2 norm of the difference is below 10E\sphinxhyphen{}12

\sphinxAtStartPar
Then the positive and negative versions of these constraints {[} \sphinxhyphen{}x \textless{} \sphinxhyphen{}1, x \textless{} 1 are on different sides of the same hyperplane{]} are made into a format that can be hashed (tuples of ints)

\sphinxAtStartPar
With this is is relatively strait forward to check for uniqueness with the set

\sphinxAtStartPar
The first loop scans thru all of the constraints and if the constraint contains a unique hyperplane
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
if it is a unique hyper plane store the index, add the integer representation to the set, then index the integer representation to the index

\item {} 
\sphinxAtStartPar
if it is not a unique hyperplane do nothing

\end{enumerate}

\sphinxAtStartPar
The second loop scans thru the constraints again and assigns them unique hyper plane indices and the parity(what side of the hyper plane that they are on)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{overall}} \textendash{} The solution of a multiparametric programming problem

\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns indices of fundamental hyperplanes, indices of constraints back to fundamental hyperplane, parity of constraint

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_unique\_region\_functions() (in module ppopt.upop.upop\_utils)@\spxentry{find\_unique\_region\_functions()}\spxextra{in module ppopt.upop.upop\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.upop_utils.find_unique_region_functions}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.upop\_utils.}}\sphinxbfcode{\sphinxupquote{find\_unique\_region\_functions}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}}{{ $\rightarrow$ Tuple\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\end{fulllineitems}

\index{find\_unique\_region\_hyperplanes() (in module ppopt.upop.upop\_utils)@\spxentry{find\_unique\_region\_hyperplanes()}\spxextra{in module ppopt.upop.upop\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.upop_utils.find_unique_region_hyperplanes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.upop\_utils.}}\sphinxbfcode{\sphinxupquote{find\_unique\_region\_hyperplanes}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}}{{ $\rightarrow$ Tuple\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is an overload of the find\_unique\_hyperplane function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_chebychev\_centers() (in module ppopt.upop.upop\_utils)@\spxentry{get\_chebychev\_centers()}\spxextra{in module ppopt.upop.upop\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.upop_utils.get_chebychev_centers}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.upop\_utils.}}\sphinxbfcode{\sphinxupquote{get\_chebychev\_centers}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Calculates and returns a list of all of the theta chebychev centers for the critical regions in the solution
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} An mp programming Solution

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A list of all of the chebychev centers of the regions in the solutions

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_descriptions() (in module ppopt.upop.upop\_utils)@\spxentry{get\_descriptions()}\spxextra{in module ppopt.upop.upop\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.upop_utils.get_descriptions}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.upop\_utils.}}\sphinxbfcode{\sphinxupquote{get\_descriptions}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}}{{ $\rightarrow$ dict}}
\end{fulllineitems}

\index{get\_outer\_boundaries() (in module ppopt.upop.upop\_utils)@\spxentry{get\_outer\_boundaries()}\spxextra{in module ppopt.upop.upop\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.upop_utils.get_outer_boundaries}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.upop\_utils.}}\sphinxbfcode{\sphinxupquote{get\_outer\_boundaries}}}{\emph{\DUrole{n}{indices}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{parity}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
Takes in the global constraint indices to the fundamental hyperplanes and their parity finds all planes with only one parity version aka only one verity of them appears in the original set.

\sphinxAtStartPar
This method is linear w.r.t. number of indices, by the use of sets and hash maps
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{indices}} \textendash{} list of indices that maps the solution constraints into the fundamental hyperplanes

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parity}} \textendash{} the side of the hyperplane that the constraint represents

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{verify\_outer\_boundary() (in module ppopt.upop.upop\_utils)@\spxentry{verify\_outer\_boundary()}\spxextra{in module ppopt.upop.upop\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.upop:ppopt.upop.upop_utils.verify_outer_boundary}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.upop.upop\_utils.}}\sphinxbfcode{\sphinxupquote{verify\_outer\_boundary}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}, \emph{\DUrole{n}{hyper\_indices}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{outer\_indices}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{chebychev\_centers}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}
\sphinxAtStartPar
This checks all of the possible outer boundary indices for errors, failures to solve for the minimal set of fundamental hyperplanes in the solution
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} An mp programming solution

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hyper\_indices}} \textendash{} The list of all fundamental hyperplane indices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{outer\_indices}} \textendash{} The list of identified exterior hyperplane indices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{chebychev\_centers}} \textendash{} the list of chebychev centers in the theta space for every critical region \{Optional\}

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
List of verified outer boundary constraints

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{ppopt.upop:module-ppopt.upop}}\label{\detokenize{ppopt.upop:module-contents}}\index{module@\spxentry{module}!ppopt.upop@\spxentry{ppopt.upop}}\index{ppopt.upop@\spxentry{ppopt.upop}!module@\spxentry{module}}

\subsubsection{ppopt.utils package}
\label{\detokenize{ppopt.utils:ppopt-utils-package}}\label{\detokenize{ppopt.utils::doc}}

\paragraph{Submodules}
\label{\detokenize{ppopt.utils:submodules}}

\paragraph{ppopt.utils.chebyshev\_ball module}
\label{\detokenize{ppopt.utils:module-ppopt.utils.chebyshev_ball}}\label{\detokenize{ppopt.utils:ppopt-utils-chebyshev-ball-module}}\index{module@\spxentry{module}!ppopt.utils.chebyshev\_ball@\spxentry{ppopt.utils.chebyshev\_ball}}\index{ppopt.utils.chebyshev\_ball@\spxentry{ppopt.utils.chebyshev\_ball}!module@\spxentry{module}}\index{chebyshev\_ball() (in module ppopt.utils.chebyshev\_ball)@\spxentry{chebyshev\_ball()}\spxextra{in module ppopt.utils.chebyshev\_ball}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.chebyshev_ball.chebyshev_ball}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.chebyshev\_ball.}}\sphinxbfcode{\sphinxupquote{chebyshev\_ball}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{bin\_vars}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}glpk\textquotesingle{}}}}{}
\sphinxAtStartPar
Chebyshev ball finds the largest ball inside of a polytope defined by Ax \textless{}= b
This is solved by the following LP

\sphinxAtStartPar
min\{x,r\} \sphinxhyphen{}r
\begin{description}
\item[{st:}] \leavevmode
\sphinxAtStartPar
Ax + ||A\_i||r \textless{}= b

\sphinxAtStartPar
A\_\{eq\}*x = b\_\{eq\}

\sphinxAtStartPar
r \textgreater{}=0

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} LHS Constraint Matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} RHS Constraint column vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} indices of rows that have strict equality A{[}eq{]} @ x = b{[}eq{]}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_vars}} \textendash{} indices of binary variables

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{deterministic\_solver}} \textendash{} The underlying Solver to use, eg. gurobi, ect

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the SolverOutput object, None if infeasible

\end{description}\end{quote}

\end{fulllineitems}

\index{chebyshev\_ball\_max() (in module ppopt.utils.chebyshev\_ball)@\spxentry{chebyshev\_ball\_max()}\spxextra{in module ppopt.utils.chebyshev\_ball}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.chebyshev_ball.chebyshev_ball_max}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.chebyshev\_ball.}}\sphinxbfcode{\sphinxupquote{chebyshev\_ball\_max}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{bin\_vars}\DUrole{p}{:} \DUrole{n}{Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{()}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}glpk\textquotesingle{}}}}{}~\begin{quote}

\sphinxAtStartPar
Chebyshev ball finds the smallest l\sphinxhyphen{}infinity ball the contains the polytope defined by Ax \textless{}= b. Where A has n hyper planes and d dimensions.

\sphinxAtStartPar
This is solved by the following LP
\begin{equation*}
\begin{split}\min_{x_{c} ,r ,y_{j} ,u_{j}} \quad r\end{split}
\end{equation*}\begin{description}
\item[{st:}] \leavevmode
\sphinxAtStartPar
A\textasciicircum{}Ty\_\{j\} = e\_\{j\},

\end{description}
\end{quote}
\begin{description}
\item[{orall j in \{1, .., d\}}] \leavevmode
\sphinxAtStartPar
A\textasciicircum{}Tu\_\{j\} = \sphinxhyphen{}e\_\{j\},

\end{description}

\sphinxAtStartPar
orall j in \{1, .., d\}
\begin{quote}
\begin{quote}

\sphinxAtStartPar
\sphinxhyphen{}x\_c{[}j{]} + \sphinxhref{mailto:b.T@y\_\{j}{b.T@y\_\{j}\} leq r
x\_c{[}j{]} + \sphinxhref{mailto:b.T@u\_\{j}{b.T@u\_\{j}\} leq r

\sphinxAtStartPar
r \textgreater{}=0
y\_\{j\} \textgreater{}= 0
u\_\{j\} \textgreater{}= 0

\sphinxAtStartPar
r in R
y\_\{j\} in R\textasciicircum{}n
u\_\{j\} in R\textasciicircum{}n
x\_c in R\textasciicircum{}d
\end{quote}

\sphinxAtStartPar
Source: Simon Foucart’s excellent book
\begin{quote}\begin{description}
\item[{param A}] \leavevmode
\sphinxAtStartPar
LHS Constraint Matrix

\item[{param b}] \leavevmode
\sphinxAtStartPar
RHS Constraint column vector

\item[{param equality\_constraints}] \leavevmode
\sphinxAtStartPar
indices of rows that have strict equality A{[}eq{]} @ x = b{[}eq{]}

\item[{param bin\_vars}] \leavevmode
\sphinxAtStartPar
indices of binary variables

\item[{param deterministic\_solver}] \leavevmode
\sphinxAtStartPar
The underlying Solver to use, eg. gurobi, ect

\item[{return}] \leavevmode
\sphinxAtStartPar
the SolverOutput object, None if infeasible

\end{description}\end{quote}
\end{quote}

\end{fulllineitems}



\paragraph{ppopt.utils.constraint\_utilities module}
\label{\detokenize{ppopt.utils:module-ppopt.utils.constraint_utilities}}\label{\detokenize{ppopt.utils:ppopt-utils-constraint-utilities-module}}\index{module@\spxentry{module}!ppopt.utils.constraint\_utilities@\spxentry{ppopt.utils.constraint\_utilities}}\index{ppopt.utils.constraint\_utilities@\spxentry{ppopt.utils.constraint\_utilities}!module@\spxentry{module}}\index{calculate\_redundant\_constraints() (in module ppopt.utils.constraint\_utilities)@\spxentry{calculate\_redundant\_constraints()}\spxextra{in module ppopt.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.constraint_utilities.calculate_redundant_constraints}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{calculate\_redundant\_constraints}}}{\emph{\DUrole{n}{A}}, \emph{\DUrole{n}{b}}}{}
\sphinxAtStartPar
Removes weakly redundant constraints, method is from the appendix of the Oberdieck paper

\sphinxAtStartPar
url: \sphinxurl{https://www.sciencedirect.com/science/article/pii/S0005109816303971}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} LHS constraint matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} RHS constraint column vector

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The processes constraint pair {[}A, b{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{cheap\_remove\_redundant\_constraints() (in module ppopt.utils.constraint\_utilities)@\spxentry{cheap\_remove\_redundant\_constraints()}\spxextra{in module ppopt.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.constraint_utilities.cheap_remove_redundant_constraints}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{cheap\_remove\_redundant\_constraints}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Removes zero rows, normalizes the constraint rows to ||A\_i||\_\{L\_2\} = 1, and removes duplicate rows
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} LHS constraint matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} RHS constraint column vector

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The processes constraint pair {[}A, b{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{constraint\_norm() (in module ppopt.utils.constraint\_utilities)@\spxentry{constraint\_norm()}\spxextra{in module ppopt.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.constraint_utilities.constraint_norm}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{constraint\_norm}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Finds the L2 norm of each row of a matrix
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} numpy matrix

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A column vector of the row norms

\end{description}\end{quote}

\end{fulllineitems}

\index{detect\_implicit\_equalities() (in module ppopt.utils.constraint\_utilities)@\spxentry{detect\_implicit\_equalities()}\spxextra{in module ppopt.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.constraint_utilities.detect_implicit_equalities}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{detect\_implicit\_equalities}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ List\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
Detects inequality constraints that form implicit equality constraints. This is important because inequality constraint pairs that\textbackslash{}
form equality constraints will actively mess with the true cardinality of the active set. Older solvers did not make check this and\textbackslash{}
that led to some problematic results.
\begin{equation*}
\begin{split}\begin{align*}
-\langle a, x \rangle &\leq -b\\
\langle a, x \rangle &\leq b\\
\end{align*} \implies \langle a, x \rangle = b\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} LHS of inequality set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} RHS of inequality set

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
List of all implicit inequality pairs

\end{description}\end{quote}

\end{fulllineitems}

\index{facet\_ball\_elimination() (in module ppopt.utils.constraint\_utilities)@\spxentry{facet\_ball\_elimination()}\spxextra{in module ppopt.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.constraint_utilities.facet_ball_elimination}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{facet\_ball\_elimination}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Removes weakly redundant constraints, method is from the appendix of the Oberdieck paper

\sphinxAtStartPar
url: \sphinxurl{https://www.sciencedirect.com/science/article/pii/S0005109816303971}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} LHS constraint matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} RHS constraint column vector

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The processes constraint pair {[}A, b{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_redundant\_constraints() (in module ppopt.utils.constraint\_utilities)@\spxentry{find\_redundant\_constraints()}\spxextra{in module ppopt.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.constraint_utilities.find_redundant_constraints}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{find\_redundant\_constraints}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{equality\_set}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}glpk\textquotesingle{}}}}{}
\end{fulllineitems}

\index{is\_full\_rank() (in module ppopt.utils.constraint\_utilities)@\spxentry{is\_full\_rank()}\spxextra{in module ppopt.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.constraint_utilities.is_full_rank}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{is\_full\_rank}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{indices}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ bool}}
\sphinxAtStartPar
Tests if the matrix A{[}indices{]} is full rank
Empty matrices e.g. A{[}{[}{]}{]} will default to be full rank
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{indices}} \textendash{} indices to consider in rank

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
if the matrix is full rank or not

\end{description}\end{quote}

\end{fulllineitems}

\index{process\_region\_constraints() (in module ppopt.utils.constraint\_utilities)@\spxentry{process\_region\_constraints()}\spxextra{in module ppopt.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.constraint_utilities.process_region_constraints}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{process\_region\_constraints}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Removes all strongly and weakly redundant constraints
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} LHS constraint matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} RHS constraint column vector

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The processes constraint pair {[}A, b{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_duplicate\_rows() (in module ppopt.utils.constraint\_utilities)@\spxentry{remove\_duplicate\_rows()}\spxextra{in module ppopt.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.constraint_utilities.remove_duplicate_rows}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{remove\_duplicate\_rows}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Finds and removes duplicate rows in the constraints A @ x \textless{}= b

\end{fulllineitems}

\index{remove\_strongly\_redundant\_constraints() (in module ppopt.utils.constraint\_utilities)@\spxentry{remove\_strongly\_redundant\_constraints()}\spxextra{in module ppopt.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.constraint_utilities.remove_strongly_redundant_constraints}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{remove\_strongly\_redundant\_constraints}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{include\_kept\_indices}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Removes strongly redundant constraints by testing the feasibility of each constraint if activated

\end{fulllineitems}

\index{remove\_zero\_rows() (in module ppopt.utils.constraint\_utilities)@\spxentry{remove\_zero\_rows()}\spxextra{in module ppopt.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.constraint_utilities.remove_zero_rows}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{remove\_zero\_rows}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Finds rows equal to zero in A and then removes them from A and b
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} LHS Matrix constraint

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} RHS Column vector

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a list{[}A\_cleaned, b\_cleaned{]} of filtered constraints

\end{description}\end{quote}

\end{fulllineitems}

\index{row\_equality() (in module ppopt.utils.constraint\_utilities)@\spxentry{row\_equality()}\spxextra{in module ppopt.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.constraint_utilities.row_equality}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{row\_equality}}}{\emph{\DUrole{n}{row\_1}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{row\_2}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{tol}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}16}}}{{ $\rightarrow$ bool}}
\sphinxAtStartPar
Tests if 2 row vectors are approximately equal
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{row\_1}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{row\_2}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tol}} \textendash{} tolerable L2 norm of the difference

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
True if rows are equal

\end{description}\end{quote}

\end{fulllineitems}

\index{scale\_constraint() (in module ppopt.utils.constraint\_utilities)@\spxentry{scale\_constraint()}\spxextra{in module ppopt.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.constraint_utilities.scale_constraint}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{scale\_constraint}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Normalizes constraints
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} LHS Matrix constraint

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} RHS column vector constraint

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a list {[}A\_scaled, b\_scaled{]} of normalized constraints

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ppopt.utils.general\_utils module}
\label{\detokenize{ppopt.utils:module-ppopt.utils.general_utils}}\label{\detokenize{ppopt.utils:ppopt-utils-general-utils-module}}\index{module@\spxentry{module}!ppopt.utils.general\_utils@\spxentry{ppopt.utils.general\_utils}}\index{ppopt.utils.general\_utils@\spxentry{ppopt.utils.general\_utils}!module@\spxentry{module}}\index{latex\_matrix() (in module ppopt.utils.general\_utils)@\spxentry{latex\_matrix()}\spxextra{in module ppopt.utils.general\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.general_utils.latex_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.general\_utils.}}\sphinxbfcode{\sphinxupquote{latex\_matrix}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}List\DUrole{p}{{[}}str\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}{{ $\rightarrow$ str}}
\sphinxAtStartPar
Creates a latex string for a given numpy array
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} A numpy array

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A latex string for the matrix A

\end{description}\end{quote}

\end{fulllineitems}

\index{make\_column() (in module ppopt.utils.general\_utils)@\spxentry{make\_column()}\spxextra{in module ppopt.utils.general\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.general_utils.make_column}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.general\_utils.}}\sphinxbfcode{\sphinxupquote{make\_column}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}List\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Makes x into a column vector
:param x: a list or a numpy array
:return: a numpy array that is a column vector

\end{fulllineitems}

\index{make\_row() (in module ppopt.utils.general\_utils)@\spxentry{make\_row()}\spxextra{in module ppopt.utils.general\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.general_utils.make_row}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.general\_utils.}}\sphinxbfcode{\sphinxupquote{make\_row}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}List\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Makes x into a row vector
:param x: a list or a numpy array
:return: a numpy array that is a row column

\end{fulllineitems}

\index{num\_cpu\_cores() (in module ppopt.utils.general\_utils)@\spxentry{num\_cpu\_cores()}\spxextra{in module ppopt.utils.general\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.general_utils.num_cpu_cores}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.general\_utils.}}\sphinxbfcode{\sphinxupquote{num\_cpu\_cores}}}{}{}
\sphinxAtStartPar
Finds the number of allocated cores,with different behavior in windows and linux.

\sphinxAtStartPar
In Windows, returns number of physical cpu cores

\sphinxAtStartPar
In Linux, returns number of available cores for processing (this is for running on cluster or managed environment)
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
number of cores

\end{description}\end{quote}

\end{fulllineitems}

\index{ppopt\_block() (in module ppopt.utils.general\_utils)@\spxentry{ppopt\_block()}\spxextra{in module ppopt.utils.general\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.general_utils.ppopt_block}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.general\_utils.}}\sphinxbfcode{\sphinxupquote{ppopt\_block}}}{\emph{\DUrole{n}{mat\_list}}}{}
\end{fulllineitems}

\index{remove\_size\_zero\_matrices() (in module ppopt.utils.general\_utils)@\spxentry{remove\_size\_zero\_matrices()}\spxextra{in module ppopt.utils.general\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.general_utils.remove_size_zero_matrices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.general\_utils.}}\sphinxbfcode{\sphinxupquote{remove\_size\_zero\_matrices}}}{\emph{\DUrole{n}{list\_matrices}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Removes size zero matrices from a list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_matrices}} \textendash{} A list of numpy arrays

\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns all matrices from the list that do not have a dimension of 0 in any index

\end{description}\end{quote}

\end{fulllineitems}

\index{render\_number() (in module ppopt.utils.general\_utils)@\spxentry{render\_number()}\spxextra{in module ppopt.utils.general\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.general_utils.render_number}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.general\_utils.}}\sphinxbfcode{\sphinxupquote{render\_number}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{trade\_off}\DUrole{o}{=}\DUrole{default_value}{0.0001}}}{{ $\rightarrow$ str}}
\end{fulllineitems}

\index{select\_not\_in\_list() (in module ppopt.utils.general\_utils)@\spxentry{select\_not\_in\_list()}\spxextra{in module ppopt.utils.general\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.general_utils.select_not_in_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.general\_utils.}}\sphinxbfcode{\sphinxupquote{select\_not\_in\_list}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{list\_}\DUrole{p}{:} \DUrole{n}{Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Filters a numpy array to select all rows that are not in a list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} a numpy array

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list}} \textendash{} a list of indices that you want to remove

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
return a numpy array of A{[}not in {\color{red}\bfseries{}list\_}{]}

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ppopt.utils.geometric module}
\label{\detokenize{ppopt.utils:module-ppopt.utils.geometric}}\label{\detokenize{ppopt.utils:ppopt-utils-geometric-module}}\index{module@\spxentry{module}!ppopt.utils.geometric@\spxentry{ppopt.utils.geometric}}\index{ppopt.utils.geometric@\spxentry{ppopt.utils.geometric}!module@\spxentry{module}}\index{gen\_tess\_points\_simplex() (in module ppopt.utils.geometric)@\spxentry{gen\_tess\_points\_simplex()}\spxextra{in module ppopt.utils.geometric}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.geometric.gen_tess_points_simplex}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.geometric.}}\sphinxbfcode{\sphinxupquote{gen\_tess\_points\_simplex}}}{\emph{\DUrole{n}{simplex}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{simplex}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{make\_domain\_subdivision() (in module ppopt.utils.geometric)@\spxentry{make\_domain\_subdivision()}\spxextra{in module ppopt.utils.geometric}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.geometric.make_domain_subdivision}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.geometric.}}\sphinxbfcode{\sphinxupquote{make\_domain\_subdivision}}}{\emph{\DUrole{n}{A\_t}}, \emph{\DUrole{n}{b\_t}}}{}
\end{fulllineitems}

\index{make\_simplex() (in module ppopt.utils.geometric)@\spxentry{make\_simplex()}\spxextra{in module ppopt.utils.geometric}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.geometric.make_simplex}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.geometric.}}\sphinxbfcode{\sphinxupquote{make\_simplex}}}{\emph{\DUrole{n}{n}\DUrole{p}{:} \DUrole{n}{int}}}{}
\end{fulllineitems}

\index{make\_subdomains() (in module ppopt.utils.geometric)@\spxentry{make\_subdomains()}\spxextra{in module ppopt.utils.geometric}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.geometric.make_subdomains}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.geometric.}}\sphinxbfcode{\sphinxupquote{make\_subdomains}}}{\emph{\DUrole{n}{points}}}{}
\end{fulllineitems}

\index{revised\_tess\_simplex() (in module ppopt.utils.geometric)@\spxentry{revised\_tess\_simplex()}\spxextra{in module ppopt.utils.geometric}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.geometric.revised_tess_simplex}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.geometric.}}\sphinxbfcode{\sphinxupquote{revised\_tess\_simplex}}}{\emph{\DUrole{n}{simplex}}, \emph{\DUrole{n}{half\_split}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\end{fulllineitems}



\paragraph{ppopt.utils.mpqp\_utils module}
\label{\detokenize{ppopt.utils:module-ppopt.utils.mpqp_utils}}\label{\detokenize{ppopt.utils:ppopt-utils-mpqp-utils-module}}\index{module@\spxentry{module}!ppopt.utils.mpqp\_utils@\spxentry{ppopt.utils.mpqp\_utils}}\index{ppopt.utils.mpqp\_utils@\spxentry{ppopt.utils.mpqp\_utils}!module@\spxentry{module}}\index{build\_suboptimal\_critical\_region() (in module ppopt.utils.mpqp\_utils)@\spxentry{build\_suboptimal\_critical\_region()}\spxextra{in module ppopt.utils.mpqp\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.mpqp_utils.build_suboptimal_critical_region}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.mpqp\_utils.}}\sphinxbfcode{\sphinxupquote{build\_suboptimal\_critical\_region}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
Builds the critical region without considering culling facets or any other operation.

\sphinxAtStartPar
Primary uses for this is based on culling lower dimensional feasible sets.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} the MQMP\_Program to be solved

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{active\_set}} \textendash{} the active set combination to build this critical region from

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Returns the associated critical region if fully dimensional else returns None

\end{description}\end{quote}

\end{fulllineitems}

\index{gen\_cr\_from\_active\_set() (in module ppopt.utils.mpqp\_utils)@\spxentry{gen\_cr\_from\_active\_set()}\spxextra{in module ppopt.utils.mpqp\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.mpqp_utils.gen_cr_from_active_set}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.mpqp\_utils.}}\sphinxbfcode{\sphinxupquote{gen\_cr\_from\_active\_set}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{check\_full\_dim}\DUrole{o}{=}\DUrole{default_value}{True}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt:ppopt.critical_region.CriticalRegion}]{\sphinxcrossref{ppopt.critical\_region.CriticalRegion}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
Builds the critical region of the given mpqp from the active set.
:param program: the MQMP\_Program to be solved
:param active\_set: the active set combination to build this critical region from
:param check\_full\_dim: Keyword Arg, if true will return null if the region has lower dimensionality
:return: Returns the associated critical region if fully dimensional else returns None

\end{fulllineitems}

\index{get\_boundary\_types() (in module ppopt.utils.mpqp\_utils)@\spxentry{get\_boundary\_types()}\spxextra{in module ppopt.utils.mpqp\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.mpqp_utils.get_boundary_types}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.mpqp\_utils.}}\sphinxbfcode{\sphinxupquote{get\_boundary\_types}}}{\emph{\DUrole{n}{region}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{omega}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{lagrange}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{regular}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ List}}
\sphinxAtStartPar
Classifies the boundaries of a polytope into Omega constraints, Lagrange multiplier = 0 constraints, and Activated program constraints
:param region:
:param omega:
:param lagrange:
:param regular:
:return:

\end{fulllineitems}

\index{is\_full\_dimensional() (in module ppopt.utils.mpqp\_utils)@\spxentry{is\_full\_dimensional()}\spxextra{in module ppopt.utils.mpqp\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt.utils:ppopt.utils.mpqp_utils.is_full_dimensional}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.utils.mpqp\_utils.}}\sphinxbfcode{\sphinxupquote{is\_full\_dimensional}}}{\emph{\DUrole{n}{A}}, \emph{\DUrole{n}{b}}, \emph{\DUrole{n}{solver}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.solver.Solver}]{\sphinxcrossref{ppopt.solver.Solver}}}} \DUrole{o}{=} \DUrole{default_value}{Solver(solvers=\{\textquotesingle{}lp\textquotesingle{}: \textquotesingle{}glpk\textquotesingle{}, \textquotesingle{}qp\textquotesingle{}: \textquotesingle{}gurobi\textquotesingle{}, \textquotesingle{}milp\textquotesingle{}: \textquotesingle{}gurobi\textquotesingle{}, \textquotesingle{}miqp\textquotesingle{}: \textquotesingle{}gurobi\textquotesingle{}\})}}}{}
\sphinxAtStartPar
This checks the dimensionality of a polytope defined by P = \{x: Ax≤b\}. Current method is based on checking if the
radii of the chebychev ball is nonzero. However this is numerically not so stable, and will eventually be replaced
by looking at the ratio of the 2 chebychev balls
:param A: LHS of polytope constraints
:param b: RHS of polytope constraints
:param solver: the solver interface to direct the deterministic solver
:return: True if polytope is fully dimensional else False

\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{ppopt.utils:module-ppopt.utils}}\label{\detokenize{ppopt.utils:module-contents}}\index{module@\spxentry{module}!ppopt.utils@\spxentry{ppopt.utils}}\index{ppopt.utils@\spxentry{ppopt.utils}!module@\spxentry{module}}

\subsection{Submodules}
\label{\detokenize{ppopt:submodules}}

\subsection{ppopt.critical\_region module}
\label{\detokenize{ppopt:module-ppopt.critical_region}}\label{\detokenize{ppopt:ppopt-critical-region-module}}\index{module@\spxentry{module}!ppopt.critical\_region@\spxentry{ppopt.critical\_region}}\index{ppopt.critical\_region@\spxentry{ppopt.critical\_region}!module@\spxentry{module}}\index{CriticalRegion (class in ppopt.critical\_region)@\spxentry{CriticalRegion}\spxextra{class in ppopt.critical\_region}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.critical_region.CriticalRegion}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ppopt.critical\_region.}}\sphinxbfcode{\sphinxupquote{CriticalRegion}}}{\emph{A: numpy.ndarray, b: numpy.ndarray, C: numpy.ndarray, d: numpy.ndarray, E: numpy.ndarray, f: numpy.ndarray, active\_set: Union{[}List{[}int{]}, numpy.ndarray{]}, omega\_set: Union{[}List{[}int{]}, numpy.ndarray{]} = \textless{}factory\textgreater{}, lambda\_set: Union{[}List{[}int{]}, numpy.ndarray{]} = \textless{}factory\textgreater{}, regular\_set: Union{[}List{[}int{]}, numpy.ndarray{]} = \textless{}factory\textgreater{}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Critical region is a polytope that defines a region in the uncertainty space
with an associated optimal value, active set, lagrange multipliers and
constraints

\sphinxAtStartPar
x(θ) = Aθ + b

\sphinxAtStartPar
λ(θ) = Cθ + d

\sphinxAtStartPar
CR := \{θ : Eθ \textless{}= f\}

\sphinxAtStartPar
equality\_indices: numpy array of indices

\sphinxAtStartPar
constraint\_set: if this is a A@x = b + \sphinxhref{mailto:F@theta}{F@theta} boundary

\sphinxAtStartPar
lambda\_set: if this is a λ = 0 boundary

\sphinxAtStartPar
boundary\_set: if this is a Eθ \textless{}= f boundary
\index{A (ppopt.critical\_region.CriticalRegion attribute)@\spxentry{A}\spxextra{ppopt.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.critical_region.CriticalRegion.A}}\pysigline{\sphinxbfcode{\sphinxupquote{A}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{C (ppopt.critical\_region.CriticalRegion attribute)@\spxentry{C}\spxextra{ppopt.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.critical_region.CriticalRegion.C}}\pysigline{\sphinxbfcode{\sphinxupquote{C}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{E (ppopt.critical\_region.CriticalRegion attribute)@\spxentry{E}\spxextra{ppopt.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.critical_region.CriticalRegion.E}}\pysigline{\sphinxbfcode{\sphinxupquote{E}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{active\_set (ppopt.critical\_region.CriticalRegion attribute)@\spxentry{active\_set}\spxextra{ppopt.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.critical_region.CriticalRegion.active_set}}\pysigline{\sphinxbfcode{\sphinxupquote{active\_set}}\sphinxbfcode{\sphinxupquote{: Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{b (ppopt.critical\_region.CriticalRegion attribute)@\spxentry{b}\spxextra{ppopt.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.critical_region.CriticalRegion.b}}\pysigline{\sphinxbfcode{\sphinxupquote{b}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{d (ppopt.critical\_region.CriticalRegion attribute)@\spxentry{d}\spxextra{ppopt.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.critical_region.CriticalRegion.d}}\pysigline{\sphinxbfcode{\sphinxupquote{d}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{evaluate() (ppopt.critical\_region.CriticalRegion method)@\spxentry{evaluate()}\spxextra{ppopt.critical\_region.CriticalRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.critical_region.CriticalRegion.evaluate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{evaluate}}}{\emph{\DUrole{n}{theta}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Evaluates x(θ) = Aθ + b

\end{fulllineitems}

\index{f (ppopt.critical\_region.CriticalRegion attribute)@\spxentry{f}\spxextra{ppopt.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.critical_region.CriticalRegion.f}}\pysigline{\sphinxbfcode{\sphinxupquote{f}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{get\_constraints() (ppopt.critical\_region.CriticalRegion method)@\spxentry{get\_constraints()}\spxextra{ppopt.critical\_region.CriticalRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.critical_region.CriticalRegion.get_constraints}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_constraints}}}{}{}
\end{fulllineitems}

\index{is\_full\_dimension() (ppopt.critical\_region.CriticalRegion method)@\spxentry{is\_full\_dimension()}\spxextra{ppopt.critical\_region.CriticalRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.critical_region.CriticalRegion.is_full_dimension}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_full\_dimension}}}{}{{ $\rightarrow$ bool}}
\sphinxAtStartPar
Tests dimensionality of critical region

\end{fulllineitems}

\index{is\_inside() (ppopt.critical\_region.CriticalRegion method)@\spxentry{is\_inside()}\spxextra{ppopt.critical\_region.CriticalRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.critical_region.CriticalRegion.is_inside}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_inside}}}{\emph{\DUrole{n}{theta}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Tests if point θ is inside of the critical region

\end{fulllineitems}

\index{lagrange\_multipliers() (ppopt.critical\_region.CriticalRegion method)@\spxentry{lagrange\_multipliers()}\spxextra{ppopt.critical\_region.CriticalRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.critical_region.CriticalRegion.lagrange_multipliers}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{lagrange\_multipliers}}}{\emph{\DUrole{n}{theta}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Evaluates λ(θ) = Cθ + d

\end{fulllineitems}

\index{lambda\_set (ppopt.critical\_region.CriticalRegion attribute)@\spxentry{lambda\_set}\spxextra{ppopt.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.critical_region.CriticalRegion.lambda_set}}\pysigline{\sphinxbfcode{\sphinxupquote{lambda\_set}}\sphinxbfcode{\sphinxupquote{: Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{omega\_set (ppopt.critical\_region.CriticalRegion attribute)@\spxentry{omega\_set}\spxextra{ppopt.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.critical_region.CriticalRegion.omega_set}}\pysigline{\sphinxbfcode{\sphinxupquote{omega\_set}}\sphinxbfcode{\sphinxupquote{: Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{regular\_set (ppopt.critical\_region.CriticalRegion attribute)@\spxentry{regular\_set}\spxextra{ppopt.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.critical_region.CriticalRegion.regular_set}}\pysigline{\sphinxbfcode{\sphinxupquote{regular\_set}}\sphinxbfcode{\sphinxupquote{: Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}
\end{fulllineitems}


\end{fulllineitems}



\subsection{ppopt.mplp\_program module}
\label{\detokenize{ppopt:module-ppopt.mplp_program}}\label{\detokenize{ppopt:ppopt-mplp-program-module}}\index{module@\spxentry{module}!ppopt.mplp\_program@\spxentry{ppopt.mplp\_program}}\index{ppopt.mplp\_program@\spxentry{ppopt.mplp\_program}!module@\spxentry{module}}\index{MPLP\_Program (class in ppopt.mplp\_program)@\spxentry{MPLP\_Program}\spxextra{class in ppopt.mplp\_program}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ppopt.mplp\_program.}}\sphinxbfcode{\sphinxupquote{MPLP\_Program}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{H}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{A\_t}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b\_t}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{F}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{equality\_indices}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{solver}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.solver.Solver}]{\sphinxcrossref{ppopt.solver.Solver}}}} \DUrole{o}{=} \DUrole{default_value}{Solver(solvers=\{\textquotesingle{}lp\textquotesingle{}: \textquotesingle{}glpk\textquotesingle{}, \textquotesingle{}qp\textquotesingle{}: \textquotesingle{}gurobi\textquotesingle{}, \textquotesingle{}milp\textquotesingle{}: \textquotesingle{}gurobi\textquotesingle{}, \textquotesingle{}miqp\textquotesingle{}: \textquotesingle{}gurobi\textquotesingle{}\})}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
The standard class for linear multiparametric programming
\index{A (ppopt.mplp\_program.MPLP\_Program attribute)@\spxentry{A}\spxextra{ppopt.mplp\_program.MPLP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.A}}\pysigline{\sphinxbfcode{\sphinxupquote{A}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{A\_t (ppopt.mplp\_program.MPLP\_Program attribute)@\spxentry{A\_t}\spxextra{ppopt.mplp\_program.MPLP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.A_t}}\pysigline{\sphinxbfcode{\sphinxupquote{A\_t}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{F (ppopt.mplp\_program.MPLP\_Program attribute)@\spxentry{F}\spxextra{ppopt.mplp\_program.MPLP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.F}}\pysigline{\sphinxbfcode{\sphinxupquote{F}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{H (ppopt.mplp\_program.MPLP\_Program attribute)@\spxentry{H}\spxextra{ppopt.mplp\_program.MPLP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.H}}\pysigline{\sphinxbfcode{\sphinxupquote{H}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{b (ppopt.mplp\_program.MPLP\_Program attribute)@\spxentry{b}\spxextra{ppopt.mplp\_program.MPLP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.b}}\pysigline{\sphinxbfcode{\sphinxupquote{b}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{b\_t (ppopt.mplp\_program.MPLP\_Program attribute)@\spxentry{b\_t}\spxextra{ppopt.mplp\_program.MPLP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.b_t}}\pysigline{\sphinxbfcode{\sphinxupquote{b\_t}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{c (ppopt.mplp\_program.MPLP\_Program attribute)@\spxentry{c}\spxextra{ppopt.mplp\_program.MPLP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.c}}\pysigline{\sphinxbfcode{\sphinxupquote{c}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{check\_active\_set\_rank() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{check\_active\_set\_rank()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.check_active_set_rank}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_active\_set\_rank}}}{\emph{\DUrole{n}{active\_set}}}{}
\end{fulllineitems}

\index{check\_feasibility() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{check\_feasibility()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.check_feasibility}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_feasibility}}}{\emph{\DUrole{n}{active\_set}}, \emph{\DUrole{n}{check\_rank}\DUrole{o}{=}\DUrole{default_value}{True}}}{{ $\rightarrow$ bool}}
\sphinxAtStartPar
Checks the feasibility of an active set combination w.r.t. a multiparametric program
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{active\_set}} \textendash{} an active set

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{check\_rank}} \textendash{} Checks the rank of the LHS matrix for a violation of LINQ if True (default)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
True if active set feasible else False

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_optimality() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{check\_optimality()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.check_optimality}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_optimality}}}{\emph{\DUrole{n}{active\_set}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{active\_set}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{constraint\_datatype\_conversion() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{constraint\_datatype\_conversion()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.constraint_datatype_conversion}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{constraint\_datatype\_conversion}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Makes sure that all of the data types of the problem are in fp64, this is important as some solvers do not accept integral data types

\end{fulllineitems}

\index{display\_latex() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{display\_latex()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.display_latex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display\_latex}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Displaces Latex text of the multiparametric problem

\end{fulllineitems}

\index{display\_warnings() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{display\_warnings()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.display_warnings}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display\_warnings}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Displaces warnings

\end{fulllineitems}

\index{equality\_indices (ppopt.mplp\_program.MPLP\_Program attribute)@\spxentry{equality\_indices}\spxextra{ppopt.mplp\_program.MPLP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.equality_indices}}\pysigline{\sphinxbfcode{\sphinxupquote{equality\_indices}}\sphinxbfcode{\sphinxupquote{: Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{evaluate\_objective() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{evaluate\_objective()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.evaluate_objective}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{evaluate\_objective}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{theta\_point}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{}
\end{fulllineitems}

\index{feasible\_space\_chebychev\_ball() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{feasible\_space\_chebychev\_ball()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.feasible_space_chebychev_ball}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{feasible\_space\_chebychev\_ball}}}{}{}
\end{fulllineitems}

\index{feasible\_theta\_point() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{feasible\_theta\_point()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.feasible_theta_point}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{feasible\_theta\_point}}}{}{{ $\rightarrow$ Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
This generates a feasible theta point for the multiparametric problem
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{gen\_feasible\_theta\_space() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{gen\_feasible\_theta\_space()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.gen_feasible_theta_space}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gen\_feasible\_theta\_space}}}{}{}
\sphinxAtStartPar
Generated the theta feasible space of a multiparametric program (with up to affine constraints)

\sphinxAtStartPar
this is done by solving the following linear program for each reduced constraint

\sphinxAtStartPar
min \sphinxhyphen{}A\_i x

\sphinxAtStartPar
s.t. Ax leq F  heta + b

\sphinxAtStartPar
then the solutions are transformed into the following results

\sphinxAtStartPar
A’ = {[}\sphinxhyphen{}F        heta; A\_theta{]}
b’ = {[}b \sphinxhyphen{} \{A\_i x\} min, b\_theta{]}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
A’, b’ for A’  heta leq b’

\end{description}\end{quote}

\end{fulllineitems}

\index{gen\_optimal\_active\_set() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{gen\_optimal\_active\_set()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.gen_optimal_active_set}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gen\_optimal\_active\_set}}}{}{{ $\rightarrow$ Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\end{fulllineitems}

\index{latex() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{latex()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.latex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{latex}}}{}{{ $\rightarrow$ List\DUrole{p}{{[}}str\DUrole{p}{{]}}}}
\sphinxAtStartPar
Generates latex of the multiparametric problem
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns latex of the

\end{description}\end{quote}

\end{fulllineitems}

\index{num\_constraints() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{num\_constraints()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.num_constraints}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{num\_constraints}}}{}{{ $\rightarrow$ int}}
\sphinxAtStartPar
Returns number of constraints

\end{fulllineitems}

\index{num\_equality\_constraints() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{num\_equality\_constraints()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.num_equality_constraints}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{num\_equality\_constraints}}}{}{{ $\rightarrow$ int}}
\end{fulllineitems}

\index{num\_inequality\_constraints() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{num\_inequality\_constraints()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.num_inequality_constraints}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{num\_inequality\_constraints}}}{}{{ $\rightarrow$ int}}
\end{fulllineitems}

\index{num\_t() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{num\_t()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.num_t}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{num\_t}}}{}{{ $\rightarrow$ int}}
\sphinxAtStartPar
Returns number of uncertain variables

\end{fulllineitems}

\index{num\_x() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{num\_x()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.num_x}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{num\_x}}}{}{{ $\rightarrow$ int}}
\sphinxAtStartPar
Returns number of parameters

\end{fulllineitems}

\index{optimal\_control\_law() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{optimal\_control\_law()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.optimal_control_law}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{optimal\_control\_law}}}{\emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}}{{ $\rightarrow$ Tuple}}
\sphinxAtStartPar
This function calculates the optimal control law corresponding to an active set combination
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{active\_set}} \textendash{} an active set combination

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a tuple of the optimal x* and λ* functions in the form x* = \sphinxhref{mailto:parameter\_A@theta}{parameter\_A@theta} + parameter\_b, λ* = \sphinxhref{mailto:lagrange\_A@theta}{lagrange\_A@theta} + lagrange\_b

\end{description}\end{quote}

\end{fulllineitems}

\index{process\_constraints() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{process\_constraints()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.process_constraints}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{process\_constraints}}}{\emph{\DUrole{n}{find\_implicit\_equalities}\DUrole{o}{=}\DUrole{default_value}{False}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Removes redundant constraints from the multiparametric programming problem

\end{fulllineitems}

\index{sample\_theta\_space() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{sample\_theta\_space()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.sample_theta_space}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sample\_theta\_space}}}{\emph{\DUrole{n}{num\_samples}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{100}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}list\DUrole{p}{{]}}}}
\sphinxAtStartPar
This samples the feasible theta space with a diken walk, NOT statistically nice as we are returning a single run of things but it is fine for this purpose
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
s

\end{description}\end{quote}

\end{fulllineitems}

\index{scale\_constraints() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{scale\_constraints()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.scale_constraints}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{scale\_constraints}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Rescales the constraints of the multiparametric problem to ||{[}A|\sphinxhyphen{}F{]}||\_i = 1, in the L2 sense

\end{fulllineitems}

\index{solve\_theta() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{solve\_theta()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.solve_theta}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve\_theta}}}{\emph{\DUrole{n}{theta\_point}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}gurobi\textquotesingle{}}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
Substitutes theta into the multiparametric problem and solves
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{theta\_point}} \textendash{} an uncertainty realization

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{deterministic\_solver}} \textendash{} Solver to use to solve the problem

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the Solver output of the substituted problem, returns None if not feasible

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_theta\_variable() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{solve\_theta\_variable()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.solve_theta_variable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve\_theta\_variable}}}{}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
Leaves Theta as an optimization variable, solves the following problem

\sphinxAtStartPar
define y’ = {[}x\textasciicircum{}T theta\textasciicircum{}T{]}\textasciicircum{}T

\sphinxAtStartPar
min {[}c\textasciicircum{}T 0{]}\textasciicircum{}Ty’
s.t. {[}A \sphinxhyphen{}F{]}y’ \textless{}= b
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
the Solver output of the substituted problem, returns None if not solvable

\end{description}\end{quote}

\end{fulllineitems}

\index{solver (ppopt.mplp\_program.MPLP\_Program attribute)@\spxentry{solver}\spxextra{ppopt.mplp\_program.MPLP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.solver}}\pysigline{\sphinxbfcode{\sphinxupquote{solver}}\sphinxbfcode{\sphinxupquote{: {\hyperref[\detokenize{ppopt:ppopt.solver.Solver}]{\sphinxcrossref{ppopt.solver.Solver}}}}}\sphinxbfcode{\sphinxupquote{ = Solver(solvers=\{\textquotesingle{}lp\textquotesingle{}: \textquotesingle{}glpk\textquotesingle{}, \textquotesingle{}qp\textquotesingle{}: \textquotesingle{}gurobi\textquotesingle{}, \textquotesingle{}milp\textquotesingle{}: \textquotesingle{}gurobi\textquotesingle{}, \textquotesingle{}miqp\textquotesingle{}: \textquotesingle{}gurobi\textquotesingle{}\})}}}
\end{fulllineitems}

\index{warnings() (ppopt.mplp\_program.MPLP\_Program method)@\spxentry{warnings()}\spxextra{ppopt.mplp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.MPLP_Program.warnings}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{warnings}}}{}{{ $\rightarrow$ List\DUrole{p}{{[}}str\DUrole{p}{{]}}}}
\sphinxAtStartPar
Checks the dimensions of the matrices to ensure consistency

\end{fulllineitems}


\end{fulllineitems}

\index{calc\_weakly\_redundant() (in module ppopt.mplp\_program)@\spxentry{calc\_weakly\_redundant()}\spxextra{in module ppopt.mplp\_program}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mplp_program.calc_weakly_redundant}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.mplp\_program.}}\sphinxbfcode{\sphinxupquote{calc\_weakly\_redundant}}}{\emph{\DUrole{n}{A}}, \emph{\DUrole{n}{b}}, \emph{\DUrole{n}{equality\_set}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}glpk\textquotesingle{}}}}{}
\end{fulllineitems}



\subsection{ppopt.mpqp\_program module}
\label{\detokenize{ppopt:module-ppopt.mpqp_program}}\label{\detokenize{ppopt:ppopt-mpqp-program-module}}\index{module@\spxentry{module}!ppopt.mpqp\_program@\spxentry{ppopt.mpqp\_program}}\index{ppopt.mpqp\_program@\spxentry{ppopt.mpqp\_program}!module@\spxentry{module}}\index{MPQP\_Program (class in ppopt.mpqp\_program)@\spxentry{MPQP\_Program}\spxextra{class in ppopt.mpqp\_program}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ppopt.mpqp\_program.}}\sphinxbfcode{\sphinxupquote{MPQP\_Program}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{H}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{Q}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{A\_t}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b\_t}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{F}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{active\_set}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{ppopt:ppopt.mplp_program.MPLP_Program}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ppopt.mplp\_program.MPLP\_Program}}}}}

\sphinxAtStartPar
The standard class for quadratic multiparametric programming, inherits from MPLP\_Program
\index{A (ppopt.mpqp\_program.MPQP\_Program attribute)@\spxentry{A}\spxextra{ppopt.mpqp\_program.MPQP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program.A}}\pysigline{\sphinxbfcode{\sphinxupquote{A}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{A\_t (ppopt.mpqp\_program.MPQP\_Program attribute)@\spxentry{A\_t}\spxextra{ppopt.mpqp\_program.MPQP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program.A_t}}\pysigline{\sphinxbfcode{\sphinxupquote{A\_t}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{F (ppopt.mpqp\_program.MPQP\_Program attribute)@\spxentry{F}\spxextra{ppopt.mpqp\_program.MPQP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program.F}}\pysigline{\sphinxbfcode{\sphinxupquote{F}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{H (ppopt.mpqp\_program.MPQP\_Program attribute)@\spxentry{H}\spxextra{ppopt.mpqp\_program.MPQP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program.H}}\pysigline{\sphinxbfcode{\sphinxupquote{H}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{b (ppopt.mpqp\_program.MPQP\_Program attribute)@\spxentry{b}\spxextra{ppopt.mpqp\_program.MPQP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program.b}}\pysigline{\sphinxbfcode{\sphinxupquote{b}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{b\_t (ppopt.mpqp\_program.MPQP\_Program attribute)@\spxentry{b\_t}\spxextra{ppopt.mpqp\_program.MPQP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program.b_t}}\pysigline{\sphinxbfcode{\sphinxupquote{b\_t}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{c (ppopt.mpqp\_program.MPQP\_Program attribute)@\spxentry{c}\spxextra{ppopt.mpqp\_program.MPQP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program.c}}\pysigline{\sphinxbfcode{\sphinxupquote{c}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{check\_optimality() (ppopt.mpqp\_program.MPQP\_Program method)@\spxentry{check\_optimality()}\spxextra{ppopt.mpqp\_program.MPQP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program.check_optimality}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_optimality}}}{\emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{list}}}{}
\sphinxAtStartPar
Tests if the active set is optimal for the provided mpqp program
\begin{quote}

\sphinxAtStartPar
x | theta | lambda | slack | t
\end{quote}
\begin{equation*}
\begin{split}\max_{x, \theta, \lambda, s, t} \quad t = \min_{x, \theta, \lambda, s, t} -t\end{split}
\end{equation*}\begin{align*}\!\begin{aligned}
1) Qu + H@theta + (A_Ai)^T lambda_Ai + c = 0\\
2) A_Ai*u - b_ai-F_ai*theta = 0\\
3) A_Aj*u - b_aj-F_aj*theta + sj_k= 0\\
4) t*e_1 <= lambda_Ai,\\
5) t*e_2 <= s_Ji\\
6) t >= 0,\\
7) lambda_Ai>= 0,\\
8) s_Ji>=0\\
9) A_t*theta<= b_t\\
\end{aligned}\end{align*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{active\_set}} \textendash{} active set being considered in the optimality test

\item[{Returns}] \leavevmode
\sphinxAtStartPar
dictionary of parameters, or None if active set is not optimal

\end{description}\end{quote}

\end{fulllineitems}

\index{equality\_indices (ppopt.mpqp\_program.MPQP\_Program attribute)@\spxentry{equality\_indices}\spxextra{ppopt.mpqp\_program.MPQP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program.equality_indices}}\pysigline{\sphinxbfcode{\sphinxupquote{equality\_indices}}\sphinxbfcode{\sphinxupquote{: Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{evaluate\_objective() (ppopt.mpqp\_program.MPQP\_Program method)@\spxentry{evaluate\_objective()}\spxextra{ppopt.mpqp\_program.MPQP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program.evaluate_objective}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{evaluate\_objective}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{theta\_point}}}{}
\end{fulllineitems}

\index{latex() (ppopt.mpqp\_program.MPQP\_Program method)@\spxentry{latex()}\spxextra{ppopt.mpqp\_program.MPQP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program.latex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{latex}}}{}{{ $\rightarrow$ List\DUrole{p}{{[}}str\DUrole{p}{{]}}}}
\sphinxAtStartPar
Creates a latex output for the multiparametric problem

\end{fulllineitems}

\index{optimal\_control\_law() (ppopt.mpqp\_program.MPQP\_Program method)@\spxentry{optimal\_control\_law()}\spxextra{ppopt.mpqp\_program.MPQP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program.optimal_control_law}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{optimal\_control\_law}}}{\emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}}{{ $\rightarrow$ Tuple}}
\sphinxAtStartPar
This function calculates the optimal control law corresponding to an active set combination
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{active\_set}} \textendash{} an active set combination

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a tuple of the optimal x* and λ* functions in the form x* = \sphinxhref{mailto:parameter\_A@theta}{parameter\_A@theta} + parameter\_b, λ* = \sphinxhref{mailto:lagrange\_A@theta}{lagrange\_A@theta} + lagrange\_b

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_theta() (ppopt.mpqp\_program.MPQP\_Program method)@\spxentry{solve\_theta()}\spxextra{ppopt.mpqp\_program.MPQP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program.solve_theta}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve\_theta}}}{\emph{\DUrole{n}{theta\_point}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}gurobi\textquotesingle{}}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
Substitutes theta into the multiparametric problem and solves
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{theta\_point}} \textendash{} an uncertainty realization

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{deterministic\_solver}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the Solver output of the substituted problem, returns None if not solvable

\end{description}\end{quote}

\end{fulllineitems}

\index{warnings() (ppopt.mpqp\_program.MPQP\_Program method)@\spxentry{warnings()}\spxextra{ppopt.mpqp\_program.MPQP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program.warnings}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{warnings}}}{}{{ $\rightarrow$ List\DUrole{p}{{[}}str\DUrole{p}{{]}}}}
\sphinxAtStartPar
Checks the dimensions of the matrices to ensure consistency

\end{fulllineitems}


\end{fulllineitems}



\subsection{ppopt.plot module}
\label{\detokenize{ppopt:module-ppopt.plot}}\label{\detokenize{ppopt:ppopt-plot-module}}\index{module@\spxentry{module}!ppopt.plot@\spxentry{ppopt.plot}}\index{ppopt.plot@\spxentry{ppopt.plot}!module@\spxentry{module}}\index{gen\_vertices() (in module ppopt.plot)@\spxentry{gen\_vertices()}\spxextra{in module ppopt.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.plot.gen_vertices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.plot.}}\sphinxbfcode{\sphinxupquote{gen\_vertices}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}}{}
\sphinxAtStartPar
Generates the vertices associated with the critical regions in the solution.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} a multiparametric region

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a list of a collection of vertices sorted counterclockwise that correspond to the specific region

\end{description}\end{quote}

\end{fulllineitems}

\index{parametric\_plot() (in module ppopt.plot)@\spxentry{parametric\_plot()}\spxextra{in module ppopt.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.plot.parametric_plot}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.plot.}}\sphinxbfcode{\sphinxupquote{parametric\_plot}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}, \emph{\DUrole{n}{save\_path}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{show}\DUrole{o}{=}\DUrole{default_value}{True}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Makes a simple plot from a solution. This uses matplotlib to generate a plot, it is the general plotting backend.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} a multiparametric solution

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{save\_path}} \textendash{} if specified saves the plot in the directory

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{show}} \textendash{} Keyword argument, if True displays the plot otherwise does not display

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
no return, creates graph of solution

\end{description}\end{quote}

\end{fulllineitems}

\index{parametric\_plot\_1D() (in module ppopt.plot)@\spxentry{parametric\_plot\_1D()}\spxextra{in module ppopt.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.plot.parametric_plot_1D}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.plot.}}\sphinxbfcode{\sphinxupquote{parametric\_plot\_1D}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}, \emph{\DUrole{n}{save\_path}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{show}\DUrole{o}{=}\DUrole{default_value}{True}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Makes a simple plot of a 1D parametric solution
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{save\_path}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{show}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{plotly\_plot() (in module ppopt.plot)@\spxentry{plotly\_plot()}\spxextra{in module ppopt.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.plot.plotly_plot}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.plot.}}\sphinxbfcode{\sphinxupquote{plotly\_plot}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.solution.Solution}]{\sphinxcrossref{ppopt.solution.Solution}}}}}, \emph{\DUrole{n}{save\_path}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{show}\DUrole{o}{=}\DUrole{default_value}{True}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Makes a plot via the plotly library, this is good for interactive figures that you can embed into webpages and handle interactively.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{save\_path}} \textendash{} Keyword argument, if a directory path is specified it will save a html copy and a png to that directory

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{show}} \textendash{} Keyword argument, if True displays the plot otherwise does not display

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
no return, creates a graph of the solution

\end{description}\end{quote}

\end{fulllineitems}

\index{sort\_clockwise() (in module ppopt.plot)@\spxentry{sort\_clockwise()}\spxextra{in module ppopt.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.plot.sort_clockwise}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.plot.}}\sphinxbfcode{\sphinxupquote{sort\_clockwise}}}{\emph{\DUrole{n}{vertices}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Sorts the vertices in clockwise order. This is important for rendering as if they were not sorted then you would see nonsense.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{vertices}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}



\subsection{ppopt.problem\_generator module}
\label{\detokenize{ppopt:module-ppopt.problem_generator}}\label{\detokenize{ppopt:ppopt-problem-generator-module}}\index{module@\spxentry{module}!ppopt.problem\_generator@\spxentry{ppopt.problem\_generator}}\index{ppopt.problem\_generator@\spxentry{ppopt.problem\_generator}!module@\spxentry{module}}\index{generate\_mplp() (in module ppopt.problem\_generator)@\spxentry{generate\_mplp()}\spxextra{in module ppopt.problem\_generator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.problem_generator.generate_mplp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.problem\_generator.}}\sphinxbfcode{\sphinxupquote{generate\_mplp}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{2}}, \emph{\DUrole{n}{t}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{2}}, \emph{\DUrole{n}{m}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{10}}}{{ $\rightarrow$ {\hyperref[\detokenize{ppopt:ppopt.mplp_program.MPLP_Program}]{\sphinxcrossref{ppopt.mplp\_program.MPLP\_Program}}}}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} number of parameters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} number of uncertain variables

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{m}} \textendash{} number of constraints

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_mpqp() (in module ppopt.problem\_generator)@\spxentry{generate\_mpqp()}\spxextra{in module ppopt.problem\_generator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.problem_generator.generate_mpqp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.problem\_generator.}}\sphinxbfcode{\sphinxupquote{generate\_mpqp}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{2}}, \emph{\DUrole{n}{t}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{2}}, \emph{\DUrole{n}{m}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{10}}}{{ $\rightarrow$ {\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}}}
\sphinxAtStartPar
Generates a random mpqp problem with of the following characteristics
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} number of x dimensions

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} number of theta dimensions

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{m}} \textendash{} number of constraints

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A random mpqp problem of the specified type

\end{description}\end{quote}

\end{fulllineitems}



\subsection{ppopt.solution module}
\label{\detokenize{ppopt:module-ppopt.solution}}\label{\detokenize{ppopt:ppopt-solution-module}}\index{module@\spxentry{module}!ppopt.solution@\spxentry{ppopt.solution}}\index{ppopt.solution@\spxentry{ppopt.solution}!module@\spxentry{module}}\index{Solution (class in ppopt.solution)@\spxentry{Solution}\spxextra{class in ppopt.solution}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solution.Solution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ppopt.solution.}}\sphinxbfcode{\sphinxupquote{Solution}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt:ppopt.mplp_program.MPLP_Program}]{\sphinxcrossref{ppopt.mplp\_program.MPLP\_Program}}}\DUrole{p}{, }{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{critical\_regions}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt:ppopt.critical_region.CriticalRegion}]{\sphinxcrossref{ppopt.critical\_region.CriticalRegion}}}\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
The Solution object is the output of multiparametric solvers, it contains all of the critical regions as well as holds a copy of the original problem that was solved
\index{add\_region() (ppopt.solution.Solution method)@\spxentry{add\_region()}\spxextra{ppopt.solution.Solution method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solution.Solution.add_region}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_region}}}{\emph{\DUrole{n}{region}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{ppopt:ppopt.critical_region.CriticalRegion}]{\sphinxcrossref{ppopt.critical\_region.CriticalRegion}}}}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Adds a region to the solution
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{region}} \textendash{} region to add to the solution

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{critical\_regions (ppopt.solution.Solution attribute)@\spxentry{critical\_regions}\spxextra{ppopt.solution.Solution attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solution.Solution.critical_regions}}\pysigline{\sphinxbfcode{\sphinxupquote{critical\_regions}}\sphinxbfcode{\sphinxupquote{: List\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt:ppopt.critical_region.CriticalRegion}]{\sphinxcrossref{ppopt.critical\_region.CriticalRegion}}}\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{evaluate() (ppopt.solution.Solution method)@\spxentry{evaluate()}\spxextra{ppopt.solution.Solution method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solution.Solution.evaluate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{evaluate}}}{\emph{\DUrole{n}{theta\_point}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}None\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
returns the optimal x* from the solution
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{theta\_point}} \textendash{} an uncertainty realization

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the calculated x* from theta

\end{description}\end{quote}

\end{fulllineitems}

\index{evaluate\_objective() (ppopt.solution.Solution method)@\spxentry{evaluate\_objective()}\spxextra{ppopt.solution.Solution method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solution.Solution.evaluate_objective}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{evaluate\_objective}}}{\emph{\DUrole{n}{theta\_point}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Given a realization of an uncertainty parameter, calculate the objective value
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{theta\_point}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_region() (ppopt.solution.Solution method)@\spxentry{get\_region()}\spxextra{ppopt.solution.Solution method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solution.Solution.get_region}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_region}}}{\emph{\DUrole{n}{theta\_point}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}None\DUrole{p}{, }{\hyperref[\detokenize{ppopt:ppopt.critical_region.CriticalRegion}]{\sphinxcrossref{ppopt.critical\_region.CriticalRegion}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
Find the critical region in the solution that corresponds to the theta provided
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{theta\_point}} \textendash{} an uncertainty realization

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the region that contains theta

\end{description}\end{quote}

\end{fulllineitems}

\index{program (ppopt.solution.Solution attribute)@\spxentry{program}\spxextra{ppopt.solution.Solution attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solution.Solution.program}}\pysigline{\sphinxbfcode{\sphinxupquote{program}}\sphinxbfcode{\sphinxupquote{: Union\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt:ppopt.mplp_program.MPLP_Program}]{\sphinxcrossref{ppopt.mplp\_program.MPLP\_Program}}}\DUrole{p}{, }{\hyperref[\detokenize{ppopt:ppopt.mpqp_program.MPQP_Program}]{\sphinxcrossref{ppopt.mpqp\_program.MPQP\_Program}}}\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{theta\_dim() (ppopt.solution.Solution method)@\spxentry{theta\_dim()}\spxextra{ppopt.solution.Solution method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solution.Solution.theta_dim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{theta\_dim}}}{}{}
\end{fulllineitems}

\index{verify\_solution() (ppopt.solution.Solution method)@\spxentry{verify\_solution()}\spxextra{ppopt.solution.Solution method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solution.Solution.verify_solution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{verify\_solution}}}{}{{ $\rightarrow$ bool}}~\begin{description}
\item[{This can be called to verify that all of the critical regions agree with the optimization problem. With problems with numerically small critical regions}] \leavevmode
\sphinxAtStartPar
the deterministic optimizer value could fail. This does NOT necessarily mean that the critical region is at fault but that perhaps more analysis should be done.This is especially apparent with critical regions with chebychev radii on the order of sqrt(machine epsilon).

\end{description}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
True if all is verified, else false

\end{description}\end{quote}

\end{fulllineitems}

\index{verify\_theta() (ppopt.solution.Solution method)@\spxentry{verify\_theta()}\spxextra{ppopt.solution.Solution method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solution.Solution.verify_theta}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{verify\_theta}}}{\emph{\DUrole{n}{theta\_point}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ bool}}
\sphinxAtStartPar
Checks that the result of the solution is consistent with theta substituted multiparametric problem
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{theta\_point}} \textendash{} an uncertainty realization

\item[{Returns}] \leavevmode
\sphinxAtStartPar
True if they are the same, False if they are different

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{ppopt.solver module}
\label{\detokenize{ppopt:module-ppopt.solver}}\label{\detokenize{ppopt:ppopt-solver-module}}\index{module@\spxentry{module}!ppopt.solver@\spxentry{ppopt.solver}}\index{ppopt.solver@\spxentry{ppopt.solver}!module@\spxentry{module}}\index{Solver (class in ppopt.solver)@\spxentry{Solver}\spxextra{class in ppopt.solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solver.Solver}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ppopt.solver.}}\sphinxbfcode{\sphinxupquote{Solver}}}{\emph{solvers: Dict{[}str}, \emph{str{]} = \textless{}factory\textgreater{}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
This is the primary user interface for deterministic solvers
\index{check\_supported\_problem() (ppopt.solver.Solver method)@\spxentry{check\_supported\_problem()}\spxextra{ppopt.solver.Solver method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solver.Solver.check_supported_problem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_supported\_problem}}}{\emph{\DUrole{n}{problem\_name}\DUrole{p}{:} \DUrole{n}{str}}}{{ $\rightarrow$ None}}
\end{fulllineitems}

\index{problem\_not\_supported() (ppopt.solver.Solver static method)@\spxentry{problem\_not\_supported()}\spxextra{ppopt.solver.Solver static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solver.Solver.problem_not_supported}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{problem\_not\_supported}}}{\emph{\DUrole{n}{problem\_name}\DUrole{p}{:} \DUrole{n}{str}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
This is an internal method that throws an error and prompts the user when they use an unsupported Solver

\end{fulllineitems}

\index{solve\_lp() (ppopt.solver.Solver method)@\spxentry{solve\_lp()}\spxextra{ppopt.solver.Solver method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solver.Solver.solve_lp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve\_lp}}}{\emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{o}{=}\DUrole{default_value}{True}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving linear programs
\begin{description}
\item[{The Linear programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{xy\} c\textasciicircum{}T@{[}xy{]}
\begin{description}
\item[{s.t.   A@x \textless{}= b}] \leavevmode
\sphinxAtStartPar
A\_eq@x = beq

\sphinxAtStartPar
x in R\textasciicircum{}n

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True (false for all mixed integer models)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A SolverOutput object if optima found, otherwise None.

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_milp() (ppopt.solver.Solver method)@\spxentry{solve\_milp()}\spxextra{ppopt.solver.Solver method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solver.Solver.solve_milp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve\_milp}}}{\emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{bin\_vars}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{o}{=}\DUrole{default_value}{True}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving mixed integer linear programs
\begin{description}
\item[{The Mixed Integer Linear programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{xy\} c\textasciicircum{}T*{[}xy{]}
\begin{description}
\item[{s.t.   A{[}xy{]} \textless{}= b}] \leavevmode
\sphinxAtStartPar
Aeq*{[}xy{]} = beq

\sphinxAtStartPar
xy is the parameter vector of mixed real and binary inputs
x in R\textasciicircum{}n
y in \{0, 1\}\textasciicircum{}m

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_vars}} \textendash{} List of binary variable indices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True (false for all mixed integer models)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A dictionary of the Solver outputs, or none if infeasible or unbounded. output{[}‘sol’{]} = primal variables, output{[}‘dual’{]} = dual variables, output{[}‘obj’{]} = objective value, output{[}‘const’{]} = slacks, output{[}‘active’{]} = active constraints.

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_miqp() (ppopt.solver.Solver method)@\spxentry{solve\_miqp()}\spxextra{ppopt.solver.Solver method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solver.Solver.solve_miqp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve\_miqp}}}{\emph{\DUrole{n}{Q}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{bin\_vars}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving mixed integer quadratic programs
\begin{description}
\item[{The Mixed Integer Quadratic program programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{xy\} 1/2 {[}xy{]}\textasciicircum{}T@Q@{[}xy{]} + c\textasciicircum{}T@{[}xy{]}
\begin{description}
\item[{s.t.   A@{[}xy{]} \textless{}= b}] \leavevmode
\sphinxAtStartPar
A\_eq@{[}xy{]} = beq

\sphinxAtStartPar
xy is the parameter vector of mixed real and binary inputs
x in R\textasciicircum{}n
y in \{0, 1\}\textasciicircum{}m

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Q}} \textendash{} Square matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_vars}} \textendash{} List of binary variable indices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True (false for all mixed integer models)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A SolverOutput object if optima found, otherwise None.

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_qp() (ppopt.solver.Solver method)@\spxentry{solve\_qp()}\spxextra{ppopt.solver.Solver method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solver.Solver.solve_qp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve\_qp}}}{\emph{\DUrole{n}{Q}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{o}{=}\DUrole{default_value}{True}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{ppopt.solver_interface:ppopt.solver_interface.solver_interface_utils.SolverOutput}]{\sphinxcrossref{ppopt.solver\_interface.solver\_interface\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving quadratic programs
\begin{description}
\item[{The Quadratic programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{x\} 1/2 x\textasciicircum{}T@Q@x + c\textasciicircum{}T@x
\begin{description}
\item[{s.t.   A@x \textless{}= b}] \leavevmode
\sphinxAtStartPar
A\_eq@x = beq

\sphinxAtStartPar
x in R\textasciicircum{}n

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Q}} \textendash{} Square matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True (false for all mixed integer models)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A SolverOutput object if optima found, otherwise None.

\end{description}\end{quote}

\end{fulllineitems}

\index{solver\_not\_supported() (ppopt.solver.Solver static method)@\spxentry{solver\_not\_supported()}\spxextra{ppopt.solver.Solver static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solver.Solver.solver_not_supported}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{solver\_not\_supported}}}{\emph{\DUrole{n}{solver\_name}\DUrole{p}{:} \DUrole{n}{str}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
This is an internal method that throws an error and prompts the user when they use an unsupported Solver

\end{fulllineitems}

\index{solvers (ppopt.solver.Solver attribute)@\spxentry{solvers}\spxextra{ppopt.solver.Solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solver.Solver.solvers}}\pysigline{\sphinxbfcode{\sphinxupquote{solvers}}\sphinxbfcode{\sphinxupquote{: Dict\DUrole{p}{{[}}str\DUrole{p}{, }str\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{supported\_problems (ppopt.solver.Solver attribute)@\spxentry{supported\_problems}\spxextra{ppopt.solver.Solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solver.Solver.supported_problems}}\pysigline{\sphinxbfcode{\sphinxupquote{supported\_problems}}\sphinxbfcode{\sphinxupquote{ = {[}\textquotesingle{}lp\textquotesingle{}, \textquotesingle{}qp\textquotesingle{}, \textquotesingle{}milp\textquotesingle{}, \textquotesingle{}miqp\textquotesingle{}{]}}}}
\end{fulllineitems}

\index{supported\_solvers (ppopt.solver.Solver attribute)@\spxentry{supported\_solvers}\spxextra{ppopt.solver.Solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solver.Solver.supported_solvers}}\pysigline{\sphinxbfcode{\sphinxupquote{supported\_solvers}}\sphinxbfcode{\sphinxupquote{ = {[}\textquotesingle{}gurobi\textquotesingle{}, \textquotesingle{}glpk\textquotesingle{}, \textquotesingle{}quadprog\textquotesingle{}{]}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{avalable\_LP\_solvers() (in module ppopt.solver)@\spxentry{avalable\_LP\_solvers()}\spxextra{in module ppopt.solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solver.avalable_LP_solvers}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver.}}\sphinxbfcode{\sphinxupquote{avalable\_LP\_solvers}}}{}{}
\end{fulllineitems}

\index{avalable\_QP\_solvers() (in module ppopt.solver)@\spxentry{avalable\_QP\_solvers()}\spxextra{in module ppopt.solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solver.avalable_QP_solvers}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver.}}\sphinxbfcode{\sphinxupquote{avalable\_QP\_solvers}}}{}{}
\end{fulllineitems}

\index{check\_modules() (in module ppopt.solver)@\spxentry{check\_modules()}\spxextra{in module ppopt.solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solver.check_modules}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver.}}\sphinxbfcode{\sphinxupquote{check\_modules}}}{\emph{\DUrole{n}{modules}\DUrole{p}{:} \DUrole{n}{Iterable}}}{}
\end{fulllineitems}

\index{check\_solver\_modules() (in module ppopt.solver)@\spxentry{check\_solver\_modules()}\spxextra{in module ppopt.solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solver.check_solver_modules}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver.}}\sphinxbfcode{\sphinxupquote{check\_solver\_modules}}}{\emph{\DUrole{n}{module\_map}}, \emph{\DUrole{n}{packages}}}{}
\end{fulllineitems}

\index{default\_solver\_options() (in module ppopt.solver)@\spxentry{default\_solver\_options()}\spxextra{in module ppopt.solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ppopt:ppopt.solver.default_solver_options}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ppopt.solver.}}\sphinxbfcode{\sphinxupquote{default\_solver\_options}}}{}{}
\end{fulllineitems}



\subsection{Module contents}
\label{\detokenize{ppopt:module-ppopt}}\label{\detokenize{ppopt:module-contents}}\index{module@\spxentry{module}!ppopt@\spxentry{ppopt}}\index{ppopt@\spxentry{ppopt}!module@\spxentry{module}}

\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{p}
\item\relax\sphinxstyleindexentry{ppopt}\sphinxstyleindexpageref{ppopt:\detokenize{module-ppopt}}
\item\relax\sphinxstyleindexentry{ppopt.critical\_region}\sphinxstyleindexpageref{ppopt:\detokenize{module-ppopt.critical_region}}
\item\relax\sphinxstyleindexentry{ppopt.geometry}\sphinxstyleindexpageref{ppopt.geometry:\detokenize{module-ppopt.geometry}}
\item\relax\sphinxstyleindexentry{ppopt.geometry.polytope}\sphinxstyleindexpageref{ppopt.geometry:\detokenize{module-ppopt.geometry.polytope}}
\item\relax\sphinxstyleindexentry{ppopt.geometry.polytope\_operations}\sphinxstyleindexpageref{ppopt.geometry:\detokenize{module-ppopt.geometry.polytope_operations}}
\item\relax\sphinxstyleindexentry{ppopt.mp\_solvers}\sphinxstyleindexpageref{ppopt.mp_solvers:\detokenize{module-ppopt.mp_solvers}}
\item\relax\sphinxstyleindexentry{ppopt.mp\_solvers.mpqp\_ahmadi}\sphinxstyleindexpageref{ppopt.mp_solvers:\detokenize{module-ppopt.mp_solvers.mpqp_ahmadi}}
\item\relax\sphinxstyleindexentry{ppopt.mp\_solvers.mpqp\_combinatorial}\sphinxstyleindexpageref{ppopt.mp_solvers:\detokenize{module-ppopt.mp_solvers.mpqp_combinatorial}}
\item\relax\sphinxstyleindexentry{ppopt.mp\_solvers.mpqp\_geometric}\sphinxstyleindexpageref{ppopt.mp_solvers:\detokenize{module-ppopt.mp_solvers.mpqp_geometric}}
\item\relax\sphinxstyleindexentry{ppopt.mp\_solvers.mpqp\_graph}\sphinxstyleindexpageref{ppopt.mp_solvers:\detokenize{module-ppopt.mp_solvers.mpqp_graph}}
\item\relax\sphinxstyleindexentry{ppopt.mp\_solvers.mpqp\_parallel\_geometric}\sphinxstyleindexpageref{ppopt.mp_solvers:\detokenize{module-ppopt.mp_solvers.mpqp_parallel_geometric}}
\item\relax\sphinxstyleindexentry{ppopt.mp\_solvers.mpqp\_parallel\_geometric\_exp}\sphinxstyleindexpageref{ppopt.mp_solvers:\detokenize{module-ppopt.mp_solvers.mpqp_parallel_geometric_exp}}
\item\relax\sphinxstyleindexentry{ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial}\sphinxstyleindexpageref{ppopt.mp_solvers:\detokenize{module-ppopt.mp_solvers.mpqp_parrallel_combinatorial}}
\item\relax\sphinxstyleindexentry{ppopt.mp\_solvers.mpqp\_parrallel\_combinatorial\_exp}\sphinxstyleindexpageref{ppopt.mp_solvers:\detokenize{module-ppopt.mp_solvers.mpqp_parrallel_combinatorial_exp}}
\item\relax\sphinxstyleindexentry{ppopt.mp\_solvers.mpqp\_parrallel\_graph}\sphinxstyleindexpageref{ppopt.mp_solvers:\detokenize{module-ppopt.mp_solvers.mpqp_parrallel_graph}}
\item\relax\sphinxstyleindexentry{ppopt.mp\_solvers.solve\_mplp}\sphinxstyleindexpageref{ppopt.mp_solvers:\detokenize{module-ppopt.mp_solvers.solve_mplp}}
\item\relax\sphinxstyleindexentry{ppopt.mp\_solvers.solve\_mpqp}\sphinxstyleindexpageref{ppopt.mp_solvers:\detokenize{module-ppopt.mp_solvers.solve_mpqp}}
\item\relax\sphinxstyleindexentry{ppopt.mp\_solvers.solver\_utils}\sphinxstyleindexpageref{ppopt.mp_solvers:\detokenize{module-ppopt.mp_solvers.solver_utils}}
\item\relax\sphinxstyleindexentry{ppopt.mplp\_program}\sphinxstyleindexpageref{ppopt:\detokenize{module-ppopt.mplp_program}}
\item\relax\sphinxstyleindexentry{ppopt.mpqp\_program}\sphinxstyleindexpageref{ppopt:\detokenize{module-ppopt.mpqp_program}}
\item\relax\sphinxstyleindexentry{ppopt.plot}\sphinxstyleindexpageref{ppopt:\detokenize{module-ppopt.plot}}
\item\relax\sphinxstyleindexentry{ppopt.problem\_generator}\sphinxstyleindexpageref{ppopt:\detokenize{module-ppopt.problem_generator}}
\item\relax\sphinxstyleindexentry{ppopt.solution}\sphinxstyleindexpageref{ppopt:\detokenize{module-ppopt.solution}}
\item\relax\sphinxstyleindexentry{ppopt.solver}\sphinxstyleindexpageref{ppopt:\detokenize{module-ppopt.solver}}
\item\relax\sphinxstyleindexentry{ppopt.solver\_interface}\sphinxstyleindexpageref{ppopt.solver_interface:\detokenize{module-ppopt.solver_interface}}
\item\relax\sphinxstyleindexentry{ppopt.solver\_interface.cvxopt\_interface}\sphinxstyleindexpageref{ppopt.solver_interface:\detokenize{module-ppopt.solver_interface.cvxopt_interface}}
\item\relax\sphinxstyleindexentry{ppopt.solver\_interface.gurobi\_solver\_interface}\sphinxstyleindexpageref{ppopt.solver_interface:\detokenize{module-ppopt.solver_interface.gurobi_solver_interface}}
\item\relax\sphinxstyleindexentry{ppopt.solver\_interface.quad\_prog\_interface}\sphinxstyleindexpageref{ppopt.solver_interface:\detokenize{module-ppopt.solver_interface.quad_prog_interface}}
\item\relax\sphinxstyleindexentry{ppopt.solver\_interface.solver\_interface}\sphinxstyleindexpageref{ppopt.solver_interface:\detokenize{module-ppopt.solver_interface.solver_interface}}
\item\relax\sphinxstyleindexentry{ppopt.solver\_interface.solver\_interface\_utils}\sphinxstyleindexpageref{ppopt.solver_interface:\detokenize{module-ppopt.solver_interface.solver_interface_utils}}
\item\relax\sphinxstyleindexentry{ppopt.upop}\sphinxstyleindexpageref{ppopt.upop:\detokenize{module-ppopt.upop}}
\item\relax\sphinxstyleindexentry{ppopt.upop.language\_generation}\sphinxstyleindexpageref{ppopt.upop:\detokenize{module-ppopt.upop.language_generation}}
\item\relax\sphinxstyleindexentry{ppopt.upop.linear\_code\_gen}\sphinxstyleindexpageref{ppopt.upop:\detokenize{module-ppopt.upop.linear_code_gen}}
\item\relax\sphinxstyleindexentry{ppopt.upop.point\_location}\sphinxstyleindexpageref{ppopt.upop:\detokenize{module-ppopt.upop.point_location}}
\item\relax\sphinxstyleindexentry{ppopt.upop.ucontroller}\sphinxstyleindexpageref{ppopt.upop:\detokenize{module-ppopt.upop.ucontroller}}
\item\relax\sphinxstyleindexentry{ppopt.upop.upop\_utils}\sphinxstyleindexpageref{ppopt.upop:\detokenize{module-ppopt.upop.upop_utils}}
\item\relax\sphinxstyleindexentry{ppopt.utils}\sphinxstyleindexpageref{ppopt.utils:\detokenize{module-ppopt.utils}}
\item\relax\sphinxstyleindexentry{ppopt.utils.chebyshev\_ball}\sphinxstyleindexpageref{ppopt.utils:\detokenize{module-ppopt.utils.chebyshev_ball}}
\item\relax\sphinxstyleindexentry{ppopt.utils.constraint\_utilities}\sphinxstyleindexpageref{ppopt.utils:\detokenize{module-ppopt.utils.constraint_utilities}}
\item\relax\sphinxstyleindexentry{ppopt.utils.general\_utils}\sphinxstyleindexpageref{ppopt.utils:\detokenize{module-ppopt.utils.general_utils}}
\item\relax\sphinxstyleindexentry{ppopt.utils.geometric}\sphinxstyleindexpageref{ppopt.utils:\detokenize{module-ppopt.utils.geometric}}
\item\relax\sphinxstyleindexentry{ppopt.utils.mpqp\_utils}\sphinxstyleindexpageref{ppopt.utils:\detokenize{module-ppopt.utils.mpqp_utils}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}