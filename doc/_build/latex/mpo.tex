%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Turotial}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{MPO}
\date{Feb 17, 2021}
\release{1.0.2}
\author{Dustin Kenefake}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
MPO is a multiparametric programming Solver written in Python, meant for solving general mpQPs and mpLPs with support for mixed integer and Quadratically constrained problems prospectively in the future. Optimized implementations of combinatorial algorithms and graph\sphinxhyphen{}based algorithms have been implemented. A focus of this Solver is to implement parallel and scalable algorithms for multithreading compute.


\chapter{Installation}
\label{\detokenize{index:installation}}
\sphinxAtStartPar
All you need to do is the following pip command in the relevant console.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip install git+https://github.com/dkenefake/mpo.git
\end{sphinxVerbatim}


\chapter{Tutorial}
\label{\detokenize{index:tutorial}}

\section{Solving a MPQP Program}
\label{\detokenize{tutorial:solving-a-mpqp-program}}\label{\detokenize{tutorial::doc}}
\sphinxAtStartPar
Here we are going to solve a classic transportation problem with multiparametric uncertainty. We have a set of plants and a set of markets with corresponding supplies and demand, and we want to minimize the transport cost between the plants and ensuring we satisfy all market demand. The multiparametric formulation is fleshed out in more detail in Multiparametric Optimization and Control by Pistikopolous et al.

\sphinxAtStartPar
This optimization problem leads to the following multiparametric optimization problem, with θ representing the markets’ uncertain demands.
\begin{equation*}
\begin{split}\min_{x} \frac{1}{2}\left[\begin{matrix}x_0\\x_1\\x_2\\x_3\end{matrix}\right]^{T}\left[\begin{matrix}306.0 & 0 & 0 & 0\\0 & 324.0 & 0 & 0\\0 & 0 & 324.0 & 0\\0 & 0 & 0 & 252.0\end{matrix}\right]\left[\begin{matrix}x_0\\x_1\\x_2\\x_3\end{matrix}\right]+\left[\begin{matrix}25.0\\25.0\\25.0\\25.0\end{matrix}\right]^T\left[\begin{matrix}x_0\\x_1\\x_2\\x_3\end{matrix}\right]\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{equation*}
\begin{split}
\text{s.t. }\left[\begin{matrix}1.0 & 1.0 & 0 & 0\\0 & 0 & 1.0 & 1.0\\-1.0 & 0 & -1.0 & 0\\0 & -1.0 & 0 & -1.0\\-1.0 & 0 & 0 & 0\\0 & -1.0 & 0 & 0\\0 & 0 & -1.0 & 0\\0 & 0 & 0 & -1.0\end{matrix}\right]\left[\begin{matrix}x_0\\x_1\\x_2\\x_3\end{matrix}\right] & \leq\left[\begin{matrix}350.0\\600.0\\0\\0\\0\\0\\0\\0\end{matrix}\right]+\left[\begin{matrix}0 & 0\\0 & 0\\-1.0 & 0\\0 & -1.0\\0 & 0\\0 & 0\\0 & 0\\0 & 0\end{matrix}\right]\left[\begin{matrix}\theta_0\\\theta_1\end{matrix}\right]\\
\left[\begin{matrix}1.0 & 0\\0 & 1.0\\-1.0 & 0\\0 & -1.0\end{matrix}\right]\left[\begin{matrix}\theta_0\\\theta_1\end{matrix}\right] & \leq\left[\begin{matrix}1e+03\\1e+03\\0\\0\end{matrix}\right]
\end{split}
\end{equation*}\end{split}
\end{equation*}
\sphinxAtStartPar
Using MPO, this is translated as the following python code. (The latex above was generated for me with \sphinxcode{\sphinxupquote{prog.latex()}} if you were wondering if I typed that all out by hand.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{350}\PYG{p}{,} \PYG{l+m+mi}{600}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{25} \PYG{o}{*} \PYG{n}{make\PYGZus{}column}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{F} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Q} \PYG{o}{=} \PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{diag}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{153}\PYG{p}{,} \PYG{l+m+mi}{162}\PYG{p}{,} \PYG{l+m+mi}{162}\PYG{p}{,} \PYG{l+m+mi}{126}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{CRa} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{vstack}\PYG{p}{(}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{CRb} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{H} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{F}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{prog} \PYG{o}{=} \PYG{n}{MPQP\PYGZus{}Program}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{H}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{CRa}\PYG{p}{,} \PYG{n}{CRb}\PYG{p}{,} \PYG{n}{F}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
But before you go forward and solve this, I would always recommend processing the constraints. Removing all strongly and weakly redundant constraints and rescaling them leads to significant performance increases and robustifying the numerical stability. In MPO, processing the constraints is a simple task.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{prog}\PYG{o}{.}\PYG{n}{process\PYGZus{}constraints}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This results in the following (identical) multiparametric optimization problem. We were able to remove 2 constraints! And we reduced the condition number of the constraints.
\begin{equation*}
\begin{split}\min_{x} \frac{1}{2}\left[\begin{matrix}x_0\\x_1\\x_2\\x_3\end{matrix}\right]^{T}\left[\begin{matrix}306.0 & 0 & 0 & 0\\0 & 324.0 & 0 & 0\\0 & 0 & 324.0 & 0\\0 & 0 & 0 & 252.0\end{matrix}\right]\left[\begin{matrix}x_0\\x_1\\x_2\\x_3\end{matrix}\right]+\left[\begin{matrix}25.0\\25.0\\25.0\\25.0\end{matrix}\right]^T\left[\begin{matrix}x_0\\x_1\\x_2\\x_3\end{matrix}\right]\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{equation*}
\begin{split}
\text{s.t. }\left[\begin{matrix}0.7071 & 0.7071 & 0 & 0\\0 & 0 & 0.7071 & 0.7071\\-0.5774 & 0 & -0.5774 & 0\\0 & -0.5774 & 0 & -0.5774\\-1.0 & 0 & 0 & 0\\0 & -1.0 & 0 & 0\\0 & 0 & -1.0 & 0\\0 & 0 & 0 & -1.0\end{matrix}\right]\left[\begin{matrix}x_0\\x_1\\x_2\\x_3\end{matrix}\right] & \leq\left[\begin{matrix}247.5\\424.3\\0\\0\\0\\0\\0\\0\end{matrix}\right]+\left[\begin{matrix}0 & 0\\0 & 0\\-0.5774 & 0\\0 & -0.5774\\0 & 0\\0 & 0\\0 & 0\\0 & 0\end{matrix}\right]\left[\begin{matrix}\theta_0\\\theta_1\end{matrix}\right]\\
\left[\begin{matrix}1.0 & 0\\0 & 1.0\\-1.0 & 0\\0 & -1.0\end{matrix}\right]\left[\begin{matrix}\theta_0\\\theta_1\end{matrix}\right] & \leq\left[\begin{matrix}1e+03\\1e+03\\0\\0\end{matrix}\right]
\end{split}
\end{equation*}\end{split}
\end{equation*}
\sphinxAtStartPar
That wasn’t that bad, and we were able to cut away some constraints that didn’t matter in the process! Now we are ready to solve it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{solution} \PYG{o}{=} \PYG{n}{mpo}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now we have the solution, we can either export the solution via the micropop module, or we can plot it. Let’s plot it here. The extra arguments mean we are saving a picture of the plot and displaying it to the user (you can give a file path, so it saves somewhere that is not the current working directory).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{parametric\PYGZus{}plot}\PYG{p}{(}\PYG{n}{solution}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transport.png}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{n}{show} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{API}
\label{\detokenize{index:api}}

\section{mpo package}
\label{\detokenize{mpo:mpo-package}}\label{\detokenize{mpo::doc}}

\subsection{Subpackages}
\label{\detokenize{mpo:subpackages}}

\subsubsection{mpo.geometry package}
\label{\detokenize{mpo.geometry:mpo-geometry-package}}\label{\detokenize{mpo.geometry::doc}}

\paragraph{Submodules}
\label{\detokenize{mpo.geometry:submodules}}

\paragraph{mpo.geometry.polytope module}
\label{\detokenize{mpo.geometry:mpo-geometry-polytope-module}}

\paragraph{mpo.geometry.polytope\_operations module}
\label{\detokenize{mpo.geometry:module-mpo.geometry.polytope_operations}}\label{\detokenize{mpo.geometry:mpo-geometry-polytope-operations-module}}\index{module@\spxentry{module}!mpo.geometry.polytope\_operations@\spxentry{mpo.geometry.polytope\_operations}}\index{mpo.geometry.polytope\_operations@\spxentry{mpo.geometry.polytope\_operations}!module@\spxentry{module}}\index{get\_chebyshev\_information() (in module mpo.geometry.polytope\_operations)@\spxentry{get\_chebyshev\_information()}\spxextra{in module mpo.geometry.polytope\_operations}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.geometry:mpo.geometry.polytope_operations.get_chebyshev_information}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.geometry.polytope\_operations.}}\sphinxbfcode{\sphinxupquote{get\_chebyshev\_information}}}{\emph{\DUrole{n}{region}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.critical_region.CriticalRegion}]{\sphinxcrossref{mpo.critical\_region.CriticalRegion}}}}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}glpk\textquotesingle{}}}}{}
\end{fulllineitems}

\index{get\_vertices() (in module mpo.geometry.polytope\_operations)@\spxentry{get\_vertices()}\spxextra{in module mpo.geometry.polytope\_operations}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.geometry:mpo.geometry.polytope_operations.get_vertices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.geometry.polytope\_operations.}}\sphinxbfcode{\sphinxupquote{get\_vertices}}}{\emph{\DUrole{n}{region}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.critical_region.CriticalRegion}]{\sphinxcrossref{mpo.critical\_region.CriticalRegion}}}}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}glpk\textquotesingle{}}}}{}
\end{fulllineitems}

\index{sample\_region\_convex\_combination() (in module mpo.geometry.polytope\_operations)@\spxentry{sample\_region\_convex\_combination()}\spxextra{in module mpo.geometry.polytope\_operations}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.geometry:mpo.geometry.polytope_operations.sample_region_convex_combination}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.geometry.polytope\_operations.}}\sphinxbfcode{\sphinxupquote{sample\_region\_convex\_combination}}}{\emph{\DUrole{n}{region}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.critical_region.CriticalRegion}]{\sphinxcrossref{mpo.critical\_region.CriticalRegion}}}}}, \emph{\DUrole{n}{dispersion}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{num\_samples}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{100}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}glpk\textquotesingle{}}}}{}
\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{mpo.geometry:module-mpo.geometry}}\label{\detokenize{mpo.geometry:module-contents}}\index{module@\spxentry{module}!mpo.geometry@\spxentry{mpo.geometry}}\index{mpo.geometry@\spxentry{mpo.geometry}!module@\spxentry{module}}

\subsubsection{mpo.mp\_solvers package}
\label{\detokenize{mpo.mp_solvers:mpo-mp-solvers-package}}\label{\detokenize{mpo.mp_solvers::doc}}

\paragraph{Submodules}
\label{\detokenize{mpo.mp_solvers:submodules}}

\paragraph{mpo.mp\_solvers.mpqp\_ahmadi module}
\label{\detokenize{mpo.mp_solvers:mpo-mp-solvers-mpqp-ahmadi-module}}

\paragraph{mpo.mp\_solvers.mpqp\_combinatorial module}
\label{\detokenize{mpo.mp_solvers:module-mpo.mp_solvers.mpqp_combinatorial}}\label{\detokenize{mpo.mp_solvers:mpo-mp-solvers-mpqp-combinatorial-module}}\index{module@\spxentry{module}!mpo.mp\_solvers.mpqp\_combinatorial@\spxentry{mpo.mp\_solvers.mpqp\_combinatorial}}\index{mpo.mp\_solvers.mpqp\_combinatorial@\spxentry{mpo.mp\_solvers.mpqp\_combinatorial}!module@\spxentry{module}}\index{CombinationTester (class in mpo.mp\_solvers.mpqp\_combinatorial)@\spxentry{CombinationTester}\spxextra{class in mpo.mp\_solvers.mpqp\_combinatorial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_combinatorial.CombinationTester}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mpo.mp\_solvers.mpqp\_combinatorial.}}\sphinxbfcode{\sphinxupquote{CombinationTester}}}{\emph{combos: List{[}List{[}int{]}{]} = \textless{}factory\textgreater{}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
This keeps track of all of the infeasible active set combinations and filters prospective active set combinations
\index{add() (mpo.mp\_solvers.mpqp\_combinatorial.CombinationTester method)@\spxentry{add()}\spxextra{mpo.mp\_solvers.mpqp\_combinatorial.CombinationTester method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_combinatorial.CombinationTester.add}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add}}}{\emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Added an infeasible active set to keep track of so we can cull later

\end{fulllineitems}

\index{check() (mpo.mp\_solvers.mpqp\_combinatorial.CombinationTester method)@\spxentry{check()}\spxextra{mpo.mp\_solvers.mpqp\_combinatorial.CombinationTester method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_combinatorial.CombinationTester.check}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check}}}{\emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}}{{ $\rightarrow$ bool}}
\sphinxAtStartPar
Checks if the provided active set combination is a superset of a previously tested infeasible active set
:param active\_set:
:return: False if it should be culled and not tested any further, True if the set could be feasible

\end{fulllineitems}

\index{combos (mpo.mp\_solvers.mpqp\_combinatorial.CombinationTester attribute)@\spxentry{combos}\spxextra{mpo.mp\_solvers.mpqp\_combinatorial.CombinationTester attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_combinatorial.CombinationTester.combos}}\pysigline{\sphinxbfcode{\sphinxupquote{combos}}\sphinxbfcode{\sphinxupquote{: List\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{check\_child\_feasibility() (in module mpo.mp\_solvers.mpqp\_combinatorial)@\spxentry{check\_child\_feasibility()}\spxextra{in module mpo.mp\_solvers.mpqp\_combinatorial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_combinatorial.check_child_feasibility}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.mp\_solvers.mpqp\_combinatorial.}}\sphinxbfcode{\sphinxupquote{check\_child\_feasibility}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{set\_list}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{combination\_checker}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_combinatorial.CombinationTester}]{\sphinxcrossref{mpo.mp\_solvers.mpqp\_combinatorial.CombinationTester}}}}}}{{ $\rightarrow$ List\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
Checks the feasibility of a list of active set combinations, if infeasible add to the combination checker and returns all feasible active set combinations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} An MPQP Program

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{set\_list}} \textendash{} The list of active sets

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{combination\_checker}} \textendash{} The combination checker that prunes

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The list of all feasible active sets

\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_children() (in module mpo.mp\_solvers.mpqp\_combinatorial)@\spxentry{generate\_children()}\spxextra{in module mpo.mp\_solvers.mpqp\_combinatorial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_combinatorial.generate_children}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.mp\_solvers.mpqp\_combinatorial.}}\sphinxbfcode{\sphinxupquote{generate\_children}}}{\emph{\DUrole{n}{program\_active\_set}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{num\_constraints}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{super\_set\_checker}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_combinatorial.CombinationTester}]{\sphinxcrossref{mpo.mp\_solvers.mpqp\_combinatorial.CombinationTester}}}}}, \emph{\DUrole{n}{root}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{()}}, \emph{\DUrole{n}{is\_root}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ List}}
\sphinxAtStartPar
Takes a child node and then finds all of the feasible (w.r.t. pruning list) active set combinations from this branch
:param program\_active\_set: base active set combinations from the multiparametric program
:param num\_constraints: number of constraints from the multi parametric program
:param super\_set\_checker: the pruning list that will check and remove all provably infeasible child sets
:param root: the base active set of the branch
:param is\_root: if this root is not active
:return: returns all the possibly feasible children of this active set

\end{fulllineitems}

\index{solve() (in module mpo.mp\_solvers.mpqp\_combinatorial)@\spxentry{solve()}\spxextra{in module mpo.mp\_solvers.mpqp\_combinatorial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_combinatorial.solve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.mp\_solvers.mpqp\_combinatorial.}}\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{Solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}gurobi\textquotesingle{}}}}{{ $\rightarrow$ {\hyperref[\detokenize{mpo:mpo.solution.Solution}]{\sphinxcrossref{mpo.solution.Solution}}}}}
\sphinxAtStartPar
Solves the MPQP program with a modified algorithm described in Gupta et. al. 2011

\sphinxAtStartPar
url: \sphinxurl{https://www.sciencedirect.com/science/article/pii/S0005109811003190}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} MPQP to be solved

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Solver}} \textendash{} Deterministic Solver to use

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the solution of the MPQP

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{mpo.mp\_solvers.mpqp\_geometric module}
\label{\detokenize{mpo.mp_solvers:module-mpo.mp_solvers.mpqp_geometric}}\label{\detokenize{mpo.mp_solvers:mpo-mp-solvers-mpqp-geometric-module}}\index{module@\spxentry{module}!mpo.mp\_solvers.mpqp\_geometric@\spxentry{mpo.mp\_solvers.mpqp\_geometric}}\index{mpo.mp\_solvers.mpqp\_geometric@\spxentry{mpo.mp\_solvers.mpqp\_geometric}!module@\spxentry{module}}\index{solve() (in module mpo.mp\_solvers.mpqp\_geometric)@\spxentry{solve()}\spxextra{in module mpo.mp\_solvers.mpqp\_geometric}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_geometric.solve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.mp\_solvers.mpqp\_geometric.}}\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{mpo:mpo.solution.Solution}]{\sphinxcrossref{mpo.solution.Solution}}}}}
\end{fulllineitems}



\paragraph{mpo.mp\_solvers.mpqp\_graph module}
\label{\detokenize{mpo.mp_solvers:module-mpo.mp_solvers.mpqp_graph}}\label{\detokenize{mpo.mp_solvers:mpo-mp-solvers-mpqp-graph-module}}\index{module@\spxentry{module}!mpo.mp\_solvers.mpqp\_graph@\spxentry{mpo.mp\_solvers.mpqp\_graph}}\index{mpo.mp\_solvers.mpqp\_graph@\spxentry{mpo.mp\_solvers.mpqp\_graph}!module@\spxentry{module}}\index{generate\_extra() (in module mpo.mp\_solvers.mpqp\_graph)@\spxentry{generate\_extra()}\spxextra{in module mpo.mp\_solvers.mpqp\_graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_graph.generate_extra}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.mp\_solvers.mpqp\_graph.}}\sphinxbfcode{\sphinxupquote{generate\_extra}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{tuple}}, \emph{\DUrole{n}{expansion\_set}}, \emph{\DUrole{n}{attempted}\DUrole{p}{:} \DUrole{n}{set}}, \emph{\DUrole{n}{murder\_list}\DUrole{p}{:} \DUrole{n}{settrie.SetTrie}}}{{ $\rightarrow$ list}}
\end{fulllineitems}

\index{generate\_reduce() (in module mpo.mp\_solvers.mpqp\_graph)@\spxentry{generate\_reduce()}\spxextra{in module mpo.mp\_solvers.mpqp\_graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_graph.generate_reduce}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.mp\_solvers.mpqp\_graph.}}\sphinxbfcode{\sphinxupquote{generate\_reduce}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{tuple}}, \emph{\DUrole{n}{attempted}\DUrole{p}{:} \DUrole{n}{set}}, \emph{\DUrole{n}{murder\_list}\DUrole{p}{:} \DUrole{n}{settrie.SetTrie}}}{{ $\rightarrow$ list}}
\end{fulllineitems}

\index{solve() (in module mpo.mp\_solvers.mpqp\_graph)@\spxentry{solve()}\spxextra{in module mpo.mp\_solvers.mpqp\_graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_graph.solve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.mp\_solvers.mpqp\_graph.}}\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{mpo:mpo.solution.Solution}]{\sphinxcrossref{mpo.solution.Solution}}}}}
\sphinxAtStartPar
Solves the MPQP program with a modified algorithm described in Oberdieck et. al. 2016

\sphinxAtStartPar
url: \sphinxurl{https://www.sciencedirect.com/science/article/pii/S0005109816303971}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} MPQP to be solved

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the solution of the MPQP

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{mpo.mp\_solvers.mpqp\_parrallel\_combinatorial module}
\label{\detokenize{mpo.mp_solvers:module-mpo.mp_solvers.mpqp_parrallel_combinatorial}}\label{\detokenize{mpo.mp_solvers:mpo-mp-solvers-mpqp-parrallel-combinatorial-module}}\index{module@\spxentry{module}!mpo.mp\_solvers.mpqp\_parrallel\_combinatorial@\spxentry{mpo.mp\_solvers.mpqp\_parrallel\_combinatorial}}\index{mpo.mp\_solvers.mpqp\_parrallel\_combinatorial@\spxentry{mpo.mp\_solvers.mpqp\_parrallel\_combinatorial}!module@\spxentry{module}}\index{CombinationTester (class in mpo.mp\_solvers.mpqp\_parrallel\_combinatorial)@\spxentry{CombinationTester}\spxextra{class in mpo.mp\_solvers.mpqp\_parrallel\_combinatorial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_parrallel_combinatorial.CombinationTester}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mpo.mp\_solvers.mpqp\_parrallel\_combinatorial.}}\sphinxbfcode{\sphinxupquote{CombinationTester}}}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
This keeps track of all of the infeasible active set combinations and filters prospective active set combinations
\index{add\_combos() (mpo.mp\_solvers.mpqp\_parrallel\_combinatorial.CombinationTester method)@\spxentry{add\_combos()}\spxextra{mpo.mp\_solvers.mpqp\_parrallel\_combinatorial.CombinationTester method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_parrallel_combinatorial.CombinationTester.add_combos}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_combos}}}{\emph{\DUrole{n}{set\_list}\DUrole{p}{:} \DUrole{n}{Set\DUrole{p}{{[}}Tuple\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}}}}{{ $\rightarrow$ None}}
\end{fulllineitems}

\index{check() (mpo.mp\_solvers.mpqp\_parrallel\_combinatorial.CombinationTester method)@\spxentry{check()}\spxextra{mpo.mp\_solvers.mpqp\_parrallel\_combinatorial.CombinationTester method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_parrallel_combinatorial.CombinationTester.check}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check}}}{\emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{Set\DUrole{p}{{[}}int\DUrole{p}{{]}}}}}{{ $\rightarrow$ bool}}
\sphinxAtStartPar
Checks if the provided active set combination is a superset of a previously tested infeasible active set
:param active\_set:
:return: False if it should be culled and not tested any further, True if the set could be feasible

\end{fulllineitems}


\end{fulllineitems}

\index{full\_process() (in module mpo.mp\_solvers.mpqp\_parrallel\_combinatorial)@\spxentry{full\_process()}\spxextra{in module mpo.mp\_solvers.mpqp\_parrallel\_combinatorial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_parrallel_combinatorial.full_process}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.mp\_solvers.mpqp\_parrallel\_combinatorial.}}\sphinxbfcode{\sphinxupquote{full\_process}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{murder\_list}}, \emph{\DUrole{n}{gen\_children}}}{}
\end{fulllineitems}

\index{generate\_children() (in module mpo.mp\_solvers.mpqp\_parrallel\_combinatorial)@\spxentry{generate\_children()}\spxextra{in module mpo.mp\_solvers.mpqp\_parrallel\_combinatorial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_parrallel_combinatorial.generate_children}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.mp\_solvers.mpqp\_parrallel\_combinatorial.}}\sphinxbfcode{\sphinxupquote{generate\_children}}}{\emph{\DUrole{n}{program\_active\_set}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{num\_constraints}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{super\_set\_checker}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_parrallel_combinatorial.CombinationTester}]{\sphinxcrossref{mpo.mp\_solvers.mpqp\_parrallel\_combinatorial.CombinationTester}}}}}, \emph{\DUrole{n}{root}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{()}}, \emph{\DUrole{n}{is\_root}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ List}}
\sphinxAtStartPar
Takes a child node and then finds all of the feasible (w.r.t. pruning list) active set combinations from this branch
:param program\_active\_set: base active set combinations from the multiparametric program
:param num\_constraints: number of constraints from the multi parametric program
:param super\_set\_checker: the pruning list that will check and remove all provably infeasible child sets
:param root: the base active set of the branch
:param is\_root: if this root is not active
:return: returns all the possibly feasible children of this active set

\end{fulllineitems}

\index{is\_feasible() (in module mpo.mp\_solvers.mpqp\_parrallel\_combinatorial)@\spxentry{is\_feasible()}\spxextra{in module mpo.mp\_solvers.mpqp\_parrallel\_combinatorial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_parrallel_combinatorial.is_feasible}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.mp\_solvers.mpqp\_parrallel\_combinatorial.}}\sphinxbfcode{\sphinxupquote{is\_feasible}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}}{{ $\rightarrow$ bool}}
\end{fulllineitems}

\index{is\_optimal() (in module mpo.mp\_solvers.mpqp\_parrallel\_combinatorial)@\spxentry{is\_optimal()}\spxextra{in module mpo.mp\_solvers.mpqp\_parrallel\_combinatorial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_parrallel_combinatorial.is_optimal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.mp\_solvers.mpqp\_parrallel\_combinatorial.}}\sphinxbfcode{\sphinxupquote{is\_optimal}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}}{{ $\rightarrow$ bool}}
\end{fulllineitems}

\index{solve() (in module mpo.mp\_solvers.mpqp\_parrallel\_combinatorial)@\spxentry{solve()}\spxextra{in module mpo.mp\_solvers.mpqp\_parrallel\_combinatorial}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_parrallel_combinatorial.solve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.mp\_solvers.mpqp\_parrallel\_combinatorial.}}\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{num\_cores}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}}{{ $\rightarrow$ {\hyperref[\detokenize{mpo:mpo.solution.Solution}]{\sphinxcrossref{mpo.solution.Solution}}}}}
\sphinxAtStartPar
Solves the MPQP program with a modified algorithm described in Gupta et. al. 2011

\sphinxAtStartPar
This is the parallel version of the combinatorial.

\sphinxAtStartPar
url: \sphinxurl{https://www.sciencedirect.com/science/article/pii/S0005109811003190}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num\_cores}} \textendash{} Sets the number of cores that are allocated to run this algorithm

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} MPQP to be solved

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the solution of the MPQP

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{mpo.mp\_solvers.mpqp\_parrallel\_combinatorial\_exp module}
\label{\detokenize{mpo.mp_solvers:mpo-mp-solvers-mpqp-parrallel-combinatorial-exp-module}}

\paragraph{mpo.mp\_solvers.mpqp\_parrallel\_graph module}
\label{\detokenize{mpo.mp_solvers:module-mpo.mp_solvers.mpqp_parrallel_graph}}\label{\detokenize{mpo.mp_solvers:mpo-mp-solvers-mpqp-parrallel-graph-module}}\index{module@\spxentry{module}!mpo.mp\_solvers.mpqp\_parrallel\_graph@\spxentry{mpo.mp\_solvers.mpqp\_parrallel\_graph}}\index{mpo.mp\_solvers.mpqp\_parrallel\_graph@\spxentry{mpo.mp\_solvers.mpqp\_parrallel\_graph}!module@\spxentry{module}}\index{solve() (in module mpo.mp\_solvers.mpqp\_parrallel\_graph)@\spxentry{solve()}\spxextra{in module mpo.mp\_solvers.mpqp\_parrallel\_graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.mpqp_parrallel_graph.solve}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.mp\_solvers.mpqp\_parrallel\_graph.}}\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{num\_cores}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}}{{ $\rightarrow$ {\hyperref[\detokenize{mpo:mpo.solution.Solution}]{\sphinxcrossref{mpo.solution.Solution}}}}}
\sphinxAtStartPar
Solves the MPQP program with a modified algorithm described in Oberdieck et. al. 2016

\sphinxAtStartPar
url: \sphinxurl{https://www.sciencedirect.com/science/article/pii/S0005109816303971}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} MPQP to be solved

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num\_cores}} \textendash{} specifies numbers of cores to run, default is set to run on all available cores

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the solution of the MPQP

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{mpo.mp\_solvers.solve\_mplp module}
\label{\detokenize{mpo.mp_solvers:module-mpo.mp_solvers.solve_mplp}}\label{\detokenize{mpo.mp_solvers:mpo-mp-solvers-solve-mplp-module}}\index{module@\spxentry{module}!mpo.mp\_solvers.solve\_mplp@\spxentry{mpo.mp\_solvers.solve\_mplp}}\index{mpo.mp\_solvers.solve\_mplp@\spxentry{mpo.mp\_solvers.solve\_mplp}!module@\spxentry{module}}\index{mplp\_solver (class in mpo.mp\_solvers.solve\_mplp)@\spxentry{mplp\_solver}\spxextra{class in mpo.mp\_solvers.solve\_mplp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.solve_mplp.mplp_solver}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mpo.mp\_solvers.solve\_mplp.}}\sphinxbfcode{\sphinxupquote{mplp\_solver}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{enum.Enum}}

\sphinxAtStartPar
An enumeration.
\index{Dustin (mpo.mp\_solvers.solve\_mplp.mplp\_solver attribute)@\spxentry{Dustin}\spxextra{mpo.mp\_solvers.solve\_mplp.mplp\_solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.solve_mplp.mplp_solver.Dustin}}\pysigline{\sphinxbfcode{\sphinxupquote{Dustin}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}1\textquotesingle{}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{solve\_mplp() (in module mpo.mp\_solvers.solve\_mplp)@\spxentry{solve\_mplp()}\spxextra{in module mpo.mp\_solvers.solve\_mplp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.solve_mplp.solve_mplp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.mp\_solvers.solve\_mplp.}}\sphinxbfcode{\sphinxupquote{solve\_mplp}}}{\emph{problem: mpo.mp\_program.MPLP\_Program}, \emph{algorithm: mpo.mp\_solvers.solve\_mplp.mplp\_solver = \textless{}mplp\_solver.Dustin: \textquotesingle{}1\textquotesingle{}\textgreater{}}}{}
\end{fulllineitems}



\paragraph{mpo.mp\_solvers.solve\_mpqp module}
\label{\detokenize{mpo.mp_solvers:module-mpo.mp_solvers.solve_mpqp}}\label{\detokenize{mpo.mp_solvers:mpo-mp-solvers-solve-mpqp-module}}\index{module@\spxentry{module}!mpo.mp\_solvers.solve\_mpqp@\spxentry{mpo.mp\_solvers.solve\_mpqp}}\index{mpo.mp\_solvers.solve\_mpqp@\spxentry{mpo.mp\_solvers.solve\_mpqp}!module@\spxentry{module}}\index{filter\_solution() (in module mpo.mp\_solvers.solve\_mpqp)@\spxentry{filter\_solution()}\spxextra{in module mpo.mp\_solvers.solve\_mpqp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.solve_mpqp.filter_solution}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.mp\_solvers.solve\_mpqp.}}\sphinxbfcode{\sphinxupquote{filter\_solution}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.solution.Solution}]{\sphinxcrossref{mpo.solution.Solution}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{mpo:mpo.solution.Solution}]{\sphinxcrossref{mpo.solution.Solution}}}}}
\end{fulllineitems}

\index{mpqp\_algorithm (class in mpo.mp\_solvers.solve\_mpqp)@\spxentry{mpqp\_algorithm}\spxextra{class in mpo.mp\_solvers.solve\_mpqp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.solve_mpqp.mpqp_algorithm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mpo.mp\_solvers.solve\_mpqp.}}\sphinxbfcode{\sphinxupquote{mpqp\_algorithm}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{enum.Enum}}

\sphinxAtStartPar
Enum that selects algorithm to be used
\index{graph (mpo.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute)@\spxentry{graph}\spxextra{mpo.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.solve_mpqp.mpqp_algorithm.graph}}\pysigline{\sphinxbfcode{\sphinxupquote{graph}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}5\textquotesingle{}}}}
\end{fulllineitems}

\index{gupta (mpo.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute)@\spxentry{gupta}\spxextra{mpo.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.solve_mpqp.mpqp_algorithm.gupta}}\pysigline{\sphinxbfcode{\sphinxupquote{gupta}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}1\textquotesingle{}}}}
\end{fulllineitems}

\index{gupta\_parallel (mpo.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute)@\spxentry{gupta\_parallel}\spxextra{mpo.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.solve_mpqp.mpqp_algorithm.gupta_parallel}}\pysigline{\sphinxbfcode{\sphinxupquote{gupta\_parallel}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}2\textquotesingle{}}}}
\end{fulllineitems}

\index{space (mpo.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute)@\spxentry{space}\spxextra{mpo.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.solve_mpqp.mpqp_algorithm.space}}\pysigline{\sphinxbfcode{\sphinxupquote{space}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}6\textquotesingle{}}}}
\end{fulllineitems}

\index{step (mpo.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute)@\spxentry{step}\spxextra{mpo.mp\_solvers.solve\_mpqp.mpqp\_algorithm attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.solve_mpqp.mpqp_algorithm.step}}\pysigline{\sphinxbfcode{\sphinxupquote{step}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}7\textquotesingle{}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{solve\_mpqp() (in module mpo.mp\_solvers.solve\_mpqp)@\spxentry{solve\_mpqp()}\spxextra{in module mpo.mp\_solvers.solve\_mpqp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.mp_solvers:mpo.mp_solvers.solve_mpqp.solve_mpqp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.mp\_solvers.solve\_mpqp.}}\sphinxbfcode{\sphinxupquote{solve\_mpqp}}}{\emph{problem: mpo.mp\_program.MPQP\_Program}, \emph{algorithm: mpo.mp\_solvers.solve\_mpqp.mpqp\_algorithm = \textless{}mpqp\_algorithm.gupta: \textquotesingle{}1\textquotesingle{}\textgreater{}}}{{ $\rightarrow$ {\hyperref[\detokenize{mpo:mpo.solution.Solution}]{\sphinxcrossref{mpo.solution.Solution}}}}}
\sphinxAtStartPar
Takes a mpqp programming problem and solves it in a specified manner

\sphinxAtStartPar
default behavior is the algorithm from Gupta et al.

\sphinxAtStartPar
Using mpqp\_algorithm as the algorithm selector

\sphinxAtStartPar
mpqp\_algorithm.gupta =\textgreater{} Gupta et al. Algorithm
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{algorithm}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{problem}} \textendash{} MPQP to be solved

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the solution of the MPQP

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{mpo.mp\_solvers.Solver\_utils module}
\label{\detokenize{mpo.mp_solvers:mpo-mp-solvers-Solver-utils-module}}

\paragraph{Module contents}
\label{\detokenize{mpo.mp_solvers:module-mpo.mp_solvers}}\label{\detokenize{mpo.mp_solvers:module-contents}}\index{module@\spxentry{module}!mpo.mp\_solvers@\spxentry{mpo.mp\_solvers}}\index{mpo.mp\_solvers@\spxentry{mpo.mp\_solvers}!module@\spxentry{module}}

\subsubsection{mpo.Solver\_interface package}
\label{\detokenize{mpo.solver_interface:mpo-Solver-interface-package}}\label{\detokenize{mpo.solver_interface::doc}}

\paragraph{Submodules}
\label{\detokenize{mpo.solver_interface:submodules}}

\paragraph{mpo.Solver\_interface.cvxopt\_interface module}
\label{\detokenize{mpo.solver_interface:module-mpo.solver_interface.cvxopt_interface}}\label{\detokenize{mpo.solver_interface:mpo-Solver-interface-cvxopt-interface-module}}\index{module@\spxentry{module}!mpo.Solver\_interface.cvxopt\_interface@\spxentry{mpo.Solver\_interface.cvxopt\_interface}}\index{mpo.Solver\_interface.cvxopt\_interface@\spxentry{mpo.Solver\_interface.cvxopt\_interface}!module@\spxentry{module}}\index{solve\_fully\_constraints() (in module mpo.Solver\_interface.cvxopt\_interface)@\spxentry{solve\_fully\_constraints()}\spxextra{in module mpo.Solver\_interface.cvxopt\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.solver_interface:mpo.solver_interface.cvxopt_interface.solve_fully_constraints}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.Solver\_interface.cvxopt\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_fully\_constraints}}}{\emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{o}{=}\DUrole{default_value}{()}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput}]{\sphinxcrossref{mpo.Solver\_interface.Solver\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\end{fulllineitems}

\index{solve\_lp\_cvxopt() (in module mpo.Solver\_interface.cvxopt\_interface)@\spxentry{solve\_lp\_cvxopt()}\spxextra{in module mpo.Solver\_interface.cvxopt\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.solver_interface:mpo.solver_interface.cvxopt_interface.solve_lp_cvxopt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.Solver\_interface.cvxopt\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_lp\_cvxopt}}}{\emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{cvx\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}glpk\textquotesingle{}}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput}]{\sphinxcrossref{mpo.Solver\_interface.Solver\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\end{fulllineitems}



\paragraph{mpo.Solver\_interface.gurobi\_solver\_interface module}
\label{\detokenize{mpo.solver_interface:module-mpo.solver_interface.gurobi_solver_interface}}\label{\detokenize{mpo.solver_interface:mpo-Solver-interface-gurobi-Solver-interface-module}}\index{module@\spxentry{module}!mpo.Solver\_interface.gurobi\_solver\_interface@\spxentry{mpo.Solver\_interface.gurobi\_solver\_interface}}\index{mpo.Solver\_interface.gurobi\_solver\_interface@\spxentry{mpo.Solver\_interface.gurobi\_solver\_interface}!module@\spxentry{module}}\index{solve\_lp\_gurobi() (in module mpo.Solver\_interface.gurobi\_solver\_interface)@\spxentry{solve\_lp\_gurobi()}\spxextra{in module mpo.Solver\_interface.gurobi\_solver\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.solver_interface:mpo.solver_interface.gurobi_solver_interface.solve_lp_gurobi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.Solver\_interface.gurobi\_solver\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_lp\_gurobi}}}{\emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{o}{=}\DUrole{default_value}{True}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput}]{\sphinxcrossref{mpo.Solver\_interface.Solver\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving mixed integer linear programs with gruobi, This is feed directly into the
MIQP Solver that is defined in the same file.
\begin{description}
\item[{The Mixed Integer Linear program programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{xy\} c\textasciicircum{}T*{[}xy{]}
\begin{description}
\item[{s.t.    A{[}xy{]} \textless{}= b}] \leavevmode
\sphinxAtStartPar
Aeq*{[}xy{]} = beq

\sphinxAtStartPar
xy is the parameter vector of mixed real and binary inputs

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A dictionary of the Solver outputs, or none if infeasible or unbounded. output{[}‘sol’{]} = primal variables, output{[}‘dual’{]} = dual variables, output{[}‘obj’{]} = objective value, output{[}‘const’{]} = slacks, output{[}‘active’{]} = active constraints.

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_milp\_gurobi() (in module mpo.Solver\_interface.gurobi\_solver\_interface)@\spxentry{solve\_milp\_gurobi()}\spxextra{in module mpo.Solver\_interface.gurobi\_solver\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.solver_interface:mpo.solver_interface.gurobi_solver_interface.solve_milp_gurobi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.Solver\_interface.gurobi\_solver\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_milp\_gurobi}}}{\emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{bin\_vars}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{o}{=}\DUrole{default_value}{True}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput}]{\sphinxcrossref{mpo.Solver\_interface.Solver\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving mixed integer linear programs with gruobi, This is feed directly into the
MIQP Solver that is defined in the same file.
\begin{description}
\item[{The Mixed Integer Linear program programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{xy\} c\textasciicircum{}T*{[}xy{]}
\begin{description}
\item[{s.t.   A{[}xy{]} \textless{}= b}] \leavevmode
\sphinxAtStartPar
Aeq*{[}xy{]} = beq
\begin{quote}

\sphinxAtStartPar
xy is the parameter vector of mixed real and binary inputs
\end{quote}

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_vars}} \textendash{} List of binary variable indices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True (false for all mixed integer models)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A dictionary of the Solver outputs, or none if infeasible or unbounded. output{[}‘sol’{]} = primal variables, output{[}‘dual’{]} = dual variables, output{[}‘obj’{]} = objective value, output{[}‘const’{]} = slacks, output{[}‘active’{]} = active constraints.

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_miqp\_gurobi() (in module mpo.Solver\_interface.gurobi\_solver\_interface)@\spxentry{solve\_miqp\_gurobi()}\spxextra{in module mpo.Solver\_interface.gurobi\_solver\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.solver_interface:mpo.solver_interface.gurobi_solver_interface.solve_miqp_gurobi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.Solver\_interface.gurobi\_solver\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_miqp\_gurobi}}}{\emph{\DUrole{n}{Q}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{bin\_vars}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput}]{\sphinxcrossref{mpo.Solver\_interface.Solver\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving mixed integer quadratic programs with gruobi
\begin{description}
\item[{The Mixed Integer Quadratic program programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{xy\} 1/2 {[}xy{]}\textasciicircum{}T*Q*{[}xy{]} + c\textasciicircum{}T*{[}xy{]}
\begin{description}
\item[{s.t.   A{[}xy{]} \textless{}= b}] \leavevmode
\sphinxAtStartPar
Aeq*{[}xy{]} = beq

\sphinxAtStartPar
xy is the parameter vector of mixed real and binary inputs

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Q}} \textendash{} Square matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_vars}} \textendash{} List of binary variable indices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True (false for all mixed integer models)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A dictionary of the Solver outputs, or none if infeasible or unbounded. n output{[}‘sol’{]} = primal

\end{description}\end{quote}

\sphinxAtStartPar
variables, output{[}‘dual’{]} = dual variables, output{[}‘obj’{]} = objective value, output{[}‘const’{]} = slacks,
output{[}‘active’{]} = active constraints.

\end{fulllineitems}

\index{solve\_qp\_gurobi() (in module mpo.Solver\_interface.gurobi\_solver\_interface)@\spxentry{solve\_qp\_gurobi()}\spxextra{in module mpo.Solver\_interface.gurobi\_solver\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.solver_interface:mpo.solver_interface.gurobi_solver_interface.solve_qp_gurobi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.Solver\_interface.gurobi\_solver\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_qp\_gurobi}}}{\emph{\DUrole{n}{Q}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{o}{=}\DUrole{default_value}{True}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput}]{\sphinxcrossref{mpo.Solver\_interface.Solver\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving mixed integer quadratic programs with gruobi
\begin{description}
\item[{The Mixed Integer Quadratic program programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{xy\} 1/2 {[}xy{]}\textasciicircum{}T*Q*{[}xy{]} + c\textasciicircum{}T*{[}xy{]}
\begin{description}
\item[{s.t.   A{[}xy{]} \textless{}= b}] \leavevmode
\sphinxAtStartPar
Aeq*{[}xy{]} = beq

\sphinxAtStartPar
xy is the parameter vector of mixed real and binary inputs

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Q}} \textendash{} Square matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True (false for all mixed integer models)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A dictionary of the Solver outputs, or none if infeasible or unbounded. n output{[}‘sol’{]} = primal variables, output{[}‘dual’{]} = dual variables, output{[}‘obj’{]} = objective value, output{[}‘const’{]} = slacks, output{[}‘active’{]} = active constraints.

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{mpo.Solver\_interface.Solver\_interface module}
\label{\detokenize{mpo.solver_interface:module-mpo.solver_interface.solver_interface}}\label{\detokenize{mpo.solver_interface:mpo-Solver-interface-Solver-interface-module}}\index{module@\spxentry{module}!mpo.Solver\_interface.Solver\_interface@\spxentry{mpo.Solver\_interface.Solver\_interface}}\index{mpo.Solver\_interface.Solver\_interface@\spxentry{mpo.Solver\_interface.Solver\_interface}!module@\spxentry{module}}\index{solve\_lp() (in module mpo.Solver\_interface.Solver\_interface)@\spxentry{solve\_lp()}\spxextra{in module mpo.Solver\_interface.Solver\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.solver_interface:mpo.solver_interface.solver_interface.solve_lp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.Solver\_interface.Solver\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_lp}}}{\emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}glpk\textquotesingle{}}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput}]{\sphinxcrossref{mpo.Solver\_interface.Solver\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving mixed integer linear programs with gruobi, This is feed directly into the
MIQP Solver that is defined in the same file.
\begin{description}
\item[{The Mixed Integer Linear program programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{xy\} c\textasciicircum{}T*{[}xy{]}
\begin{description}
\item[{s.t.    A{[}xy{]} \textless{}= b}] \leavevmode
\sphinxAtStartPar
Aeq*{[}xy{]} = beq

\sphinxAtStartPar
xy is the parameter vector of mixed real and binary inputs

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{deterministic\_solver}} \textendash{} The underlying Solver to use, eg. gurobi, ect

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A dictionary of the Solver outputs, or none if infeasible or unbounded. output{[}‘sol’{]} = primal variables, output{[}‘dual’{]} = dual variables, output{[}‘obj’{]} = objective value, output{[}‘const’{]} = slacks, output{[}‘active’{]} = active constraints.

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_milp() (in module mpo.Solver\_interface.Solver\_interface)@\spxentry{solve\_milp()}\spxextra{in module mpo.Solver\_interface.Solver\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.solver_interface:mpo.solver_interface.solver_interface.solve_milp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.Solver\_interface.Solver\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_milp}}}{\emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{bin\_vars}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}gurobi\textquotesingle{}}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput}]{\sphinxcrossref{mpo.Solver\_interface.Solver\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving mixed integer linear programs with gruobi, This is feed directly into the
MIQP Solver that is defined in the same file.
\begin{description}
\item[{The Mixed Integer Linear program programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{xy\} c\textasciicircum{}T*{[}xy{]}
\begin{description}
\item[{s.t.   A{[}xy{]} \textless{}= b}] \leavevmode
\sphinxAtStartPar
Aeq*{[}xy{]} = beq
\begin{quote}

\sphinxAtStartPar
xy is the parameter vector of mixed real and binary inputs
\end{quote}

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_vars}} \textendash{} List of binary variable indices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True (false for all mixed integer models)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{deterministic\_solver}} \textendash{} The underlying Solver to use, eg. gurobi, ect

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A dictionary of the Solver outputs, or none if infeasible or unbounded. output{[}‘sol’{]} = primal variables, output{[}‘dual’{]} = dual variables, output{[}‘obj’{]} = objective value, output{[}‘const’{]} = slacks, output{[}‘active’{]} = active constraints.

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_miqp() (in module mpo.Solver\_interface.Solver\_interface)@\spxentry{solve\_miqp()}\spxextra{in module mpo.Solver\_interface.Solver\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.solver_interface:mpo.solver_interface.solver_interface.solve_miqp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.Solver\_interface.Solver\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_miqp}}}{\emph{\DUrole{n}{Q}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{()}}, \emph{\DUrole{n}{bin\_vars}\DUrole{p}{:} \DUrole{n}{Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{()}}, \emph{\DUrole{n}{verbose}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}gurobi\textquotesingle{}}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput}]{\sphinxcrossref{mpo.Solver\_interface.Solver\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving mixed integer quadratic programs with gruobi
\begin{description}
\item[{The Mixed Integer Quadratic program programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{xy\} 1/2 {[}xy{]}\textasciicircum{}T*Q*{[}xy{]} + c\textasciicircum{}T*{[}xy{]}
\begin{description}
\item[{s.t.   A{[}xy{]} \textless{}= b}] \leavevmode
\sphinxAtStartPar
Aeq*{[}xy{]} = beq

\sphinxAtStartPar
xy is the parameter vector of mixed real and binary inputs

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Q}} \textendash{} Square matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_vars}} \textendash{} List of binary variable indices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True (false for all mixed integer models)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{deterministic\_solver}} \textendash{} The underlying Solver to use, eg. gurobi, ect

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A dictionary of the Solver outputs, or none if infeasible or unbounded. n output{[}‘sol’{]} = primal

\end{description}\end{quote}

\sphinxAtStartPar
variables, output{[}‘dual’{]} = dual variables, output{[}‘obj’{]} = objective value, output{[}‘const’{]} = slacks,
output{[}‘active’{]} = active constraints.

\end{fulllineitems}

\index{solve\_qp() (in module mpo.Solver\_interface.Solver\_interface)@\spxentry{solve\_qp()}\spxextra{in module mpo.Solver\_interface.Solver\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.solver_interface:mpo.solver_interface.solver_interface.solve_qp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.Solver\_interface.Solver\_interface.}}\sphinxbfcode{\sphinxupquote{solve\_qp}}}{\emph{\DUrole{n}{Q}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_duals}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}gurobi\textquotesingle{}}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput}]{\sphinxcrossref{mpo.Solver\_interface.Solver\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is the breakout for solving mixed integer quadratic programs with gruobi
\begin{description}
\item[{The Mixed Integer Quadratic program programming problem}] \leavevmode
\sphinxAtStartPar
min\_\{xy\} 1/2 {[}xy{]}\textasciicircum{}T*Q*{[}xy{]} + c\textasciicircum{}T*{[}xy{]}
\begin{description}
\item[{s.t.  A{[}xy{]}   \textless{}= b}] \leavevmode
\sphinxAtStartPar
Aeq*{[}xy{]} = beq

\sphinxAtStartPar
xy is the parameter vector of mixed real and binary inputs

\end{description}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Q}} \textendash{} Square matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Column Vector, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Constraint LHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} Constraint RHS matrix, can be None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} List of Equality constraints

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} Flag for output of underlying Solver, default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_duals}} \textendash{} Flag for returning dual variable of problem, default True (false for all mixed integer models)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{deterministic\_solver}} \textendash{} The underlying Solver to use, eg. gurobi, ect

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A dictionary of the Solver outputs, or none if infeasible or unbounded. n output{[}‘sol’{]} = primal variables, output{[}‘dual’{]} = dual variables, output{[}‘obj’{]} = objective value, output{[}‘const’{]} = slacks, output{[}‘active’{]} = active constraints.

\end{description}\end{quote}

\end{fulllineitems}

\index{Solver\_not\_supported() (in module mpo.Solver\_interface.Solver\_interface)@\spxentry{Solver\_not\_supported()}\spxextra{in module mpo.Solver\_interface.Solver\_interface}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.solver_interface:mpo.solver_interface.solver_interface.solver_not_supported}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.Solver\_interface.Solver\_interface.}}\sphinxbfcode{\sphinxupquote{Solver\_not\_supported}}}{\emph{\DUrole{n}{Solver\_name}\DUrole{p}{:} \DUrole{n}{str}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
This is an internal method that throws an error and prompts the user when they use an unsupported Solver

\end{fulllineitems}



\paragraph{mpo.Solver\_interface.Solver\_utils module}
\label{\detokenize{mpo.solver_interface:module-mpo.solver_interface.solver_utils}}\label{\detokenize{mpo.solver_interface:mpo-Solver-interface-Solver-utils-module}}\index{module@\spxentry{module}!mpo.Solver\_interface.Solver\_utils@\spxentry{mpo.Solver\_interface.Solver\_utils}}\index{mpo.Solver\_interface.Solver\_utils@\spxentry{mpo.Solver\_interface.Solver\_utils}!module@\spxentry{module}}\index{SolverOutput (class in mpo.Solver\_interface.Solver\_utils)@\spxentry{SolverOutput}\spxextra{class in mpo.Solver\_interface.Solver\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mpo.Solver\_interface.Solver\_utils.}}\sphinxbfcode{\sphinxupquote{SolverOutput}}}{\emph{\DUrole{n}{obj}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{sol}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{slack}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{dual}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Solver information object

\sphinxAtStartPar
Members:
obj: objective value of the optimal solution

\sphinxAtStartPar
sol: x*, numpy.ndarray

\sphinxAtStartPar
Optional Parameters \sphinxhyphen{}\textgreater{} None or numpy.ndarray type

\sphinxAtStartPar
slack: the slacks associated with every constraint

\sphinxAtStartPar
active\_set: the active set of the solution, including strongly and weakly active constraints

\sphinxAtStartPar
dual: the lagrange multipliers associated with the problem
\index{active\_set (mpo.Solver\_interface.Solver\_utils.SolverOutput attribute)@\spxentry{active\_set}\spxextra{mpo.Solver\_interface.Solver\_utils.SolverOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput.active_set}}\pysigline{\sphinxbfcode{\sphinxupquote{active\_set}}\sphinxbfcode{\sphinxupquote{: Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{dual (mpo.Solver\_interface.Solver\_utils.SolverOutput attribute)@\spxentry{dual}\spxextra{mpo.Solver\_interface.Solver\_utils.SolverOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput.dual}}\pysigline{\sphinxbfcode{\sphinxupquote{dual}}\sphinxbfcode{\sphinxupquote{: Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{obj (mpo.Solver\_interface.Solver\_utils.SolverOutput attribute)@\spxentry{obj}\spxextra{mpo.Solver\_interface.Solver\_utils.SolverOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput.obj}}\pysigline{\sphinxbfcode{\sphinxupquote{obj}}\sphinxbfcode{\sphinxupquote{: float}}}
\end{fulllineitems}

\index{slack (mpo.Solver\_interface.Solver\_utils.SolverOutput attribute)@\spxentry{slack}\spxextra{mpo.Solver\_interface.Solver\_utils.SolverOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput.slack}}\pysigline{\sphinxbfcode{\sphinxupquote{slack}}\sphinxbfcode{\sphinxupquote{: Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{sol (mpo.Solver\_interface.Solver\_utils.SolverOutput attribute)@\spxentry{sol}\spxextra{mpo.Solver\_interface.Solver\_utils.SolverOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput.sol}}\pysigline{\sphinxbfcode{\sphinxupquote{sol}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}


\end{fulllineitems}

\index{get\_program\_parameters() (in module mpo.Solver\_interface.Solver\_utils)@\spxentry{get\_program\_parameters()}\spxextra{in module mpo.Solver\_interface.Solver\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.get_program_parameters}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.Solver\_interface.Solver\_utils.}}\sphinxbfcode{\sphinxupquote{get\_program\_parameters}}}{\emph{\DUrole{n}{Q}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
Given a set of possibly None optimization parameters determine the number of variables and constraints

\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{mpo.solver_interface:module-mpo.solver_interface}}\label{\detokenize{mpo.solver_interface:module-contents}}\index{module@\spxentry{module}!mpo.Solver\_interface@\spxentry{mpo.Solver\_interface}}\index{mpo.Solver\_interface@\spxentry{mpo.Solver\_interface}!module@\spxentry{module}}

\subsubsection{mpo.upop package}
\label{\detokenize{mpo.upop:mpo-upop-package}}\label{\detokenize{mpo.upop::doc}}

\paragraph{Submodules}
\label{\detokenize{mpo.upop:submodules}}

\paragraph{mpo.upop.language\_generation module}
\label{\detokenize{mpo.upop:module-mpo.upop.language_generation}}\label{\detokenize{mpo.upop:mpo-upop-language-generation-module}}\index{module@\spxentry{module}!mpo.upop.language\_generation@\spxentry{mpo.upop.language\_generation}}\index{mpo.upop.language\_generation@\spxentry{mpo.upop.language\_generation}!module@\spxentry{module}}\index{gen\_array() (in module mpo.upop.language\_generation)@\spxentry{gen\_array()}\spxextra{in module mpo.upop.language\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.language_generation.gen_array}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.upop.language\_generation.}}\sphinxbfcode{\sphinxupquote{gen\_array}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{vartype}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{(\textquotesingle{}const\textquotesingle{})}}, \emph{\DUrole{n}{lang}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}cpp\textquotesingle{}}}}{{ $\rightarrow$ str}}
\end{fulllineitems}

\index{gen\_cpp\_array() (in module mpo.upop.language\_generation)@\spxentry{gen\_cpp\_array()}\spxextra{in module mpo.upop.language\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.language_generation.gen_cpp_array}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.upop.language\_generation.}}\sphinxbfcode{\sphinxupquote{gen\_cpp\_array}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{vartype}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{options}\DUrole{p}{:} \DUrole{n}{list} \DUrole{o}{=} \DUrole{default_value}{(\textquotesingle{}const\textquotesingle{})}}}{{ $\rightarrow$ str}}
\end{fulllineitems}

\index{gen\_cpp\_variable() (in module mpo.upop.language\_generation)@\spxentry{gen\_cpp\_variable()}\spxextra{in module mpo.upop.language\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.language_generation.gen_cpp_variable}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.upop.language\_generation.}}\sphinxbfcode{\sphinxupquote{gen\_cpp\_variable}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{vartype}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{options}\DUrole{p}{:} \DUrole{n}{list} \DUrole{o}{=} \DUrole{default_value}{(\textquotesingle{}const\textquotesingle{})}}}{{ $\rightarrow$ str}}
\end{fulllineitems}

\index{gen\_js\_array() (in module mpo.upop.language\_generation)@\spxentry{gen\_js\_array()}\spxextra{in module mpo.upop.language\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.language_generation.gen_js_array}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.upop.language\_generation.}}\sphinxbfcode{\sphinxupquote{gen\_js\_array}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{vartype}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{options}\DUrole{p}{:} \DUrole{n}{list} \DUrole{o}{=} \DUrole{default_value}{(\textquotesingle{}const\textquotesingle{})}}}{{ $\rightarrow$ str}}
\end{fulllineitems}

\index{gen\_js\_variable() (in module mpo.upop.language\_generation)@\spxentry{gen\_js\_variable()}\spxextra{in module mpo.upop.language\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.language_generation.gen_js_variable}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.upop.language\_generation.}}\sphinxbfcode{\sphinxupquote{gen\_js\_variable}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{vartype}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{options}\DUrole{p}{:} \DUrole{n}{list} \DUrole{o}{=} \DUrole{default_value}{(\textquotesingle{}const\textquotesingle{})}}}{{ $\rightarrow$ str}}
\end{fulllineitems}

\index{gen\_python\_array() (in module mpo.upop.language\_generation)@\spxentry{gen\_python\_array()}\spxextra{in module mpo.upop.language\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.language_generation.gen_python_array}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.upop.language\_generation.}}\sphinxbfcode{\sphinxupquote{gen\_python\_array}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{vartype}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{options}\DUrole{p}{:} \DUrole{n}{list} \DUrole{o}{=} \DUrole{default_value}{(\textquotesingle{}const\textquotesingle{})}}}{{ $\rightarrow$ str}}
\end{fulllineitems}

\index{gen\_python\_variable() (in module mpo.upop.language\_generation)@\spxentry{gen\_python\_variable()}\spxextra{in module mpo.upop.language\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.language_generation.gen_python_variable}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.upop.language\_generation.}}\sphinxbfcode{\sphinxupquote{gen\_python\_variable}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{vartype}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{options}\DUrole{p}{:} \DUrole{n}{list} \DUrole{o}{=} \DUrole{default_value}{(\textquotesingle{}const\textquotesingle{})}}}{{ $\rightarrow$ str}}
\end{fulllineitems}

\index{gen\_variable() (in module mpo.upop.language\_generation)@\spxentry{gen\_variable()}\spxextra{in module mpo.upop.language\_generation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.language_generation.gen_variable}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.upop.language\_generation.}}\sphinxbfcode{\sphinxupquote{gen\_variable}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{vartype}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{(\textquotesingle{}const\textquotesingle{})}}, \emph{\DUrole{n}{lang}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}cpp\textquotesingle{}}}}{{ $\rightarrow$ str}}
\end{fulllineitems}



\paragraph{mpo.upop.linear\_code\_gen module}
\label{\detokenize{mpo.upop:mpo-upop-linear-code-gen-module}}

\paragraph{mpo.upop.point\_location module}
\label{\detokenize{mpo.upop:module-mpo.upop.point_location}}\label{\detokenize{mpo.upop:mpo-upop-point-location-module}}\index{module@\spxentry{module}!mpo.upop.point\_location@\spxentry{mpo.upop.point\_location}}\index{mpo.upop.point\_location@\spxentry{mpo.upop.point\_location}!module@\spxentry{module}}\index{PointLocation (class in mpo.upop.point\_location)@\spxentry{PointLocation}\spxextra{class in mpo.upop.point\_location}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.point_location.PointLocation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mpo.upop.point\_location.}}\sphinxbfcode{\sphinxupquote{PointLocation}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.solution.Solution}]{\sphinxcrossref{mpo.solution.Solution}}}}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}
\index{evaluate() (mpo.upop.point\_location.PointLocation method)@\spxentry{evaluate()}\spxextra{mpo.upop.point\_location.PointLocation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.point_location.PointLocation.evaluate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{evaluate}}}{\emph{\DUrole{n}{theta}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Evaluates the value of x(theta), of the
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{theta}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{is\_inside() (mpo.upop.point\_location.PointLocation method)@\spxentry{is\_inside()}\spxextra{mpo.upop.point\_location.PointLocation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.point_location.PointLocation.is_inside}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_inside}}}{\emph{\DUrole{n}{theta}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ bool}}~\begin{quote}

\sphinxAtStartPar
Determines if the theta point in inside of the feasible space
\begin{quote}\begin{description}
\item[{param theta}] \leavevmode
\sphinxAtStartPar
A point in the theta space

\item[{return}] \leavevmode
\sphinxAtStartPar
True, if theta in region

\end{description}\end{quote}
\end{quote}

\sphinxAtStartPar
False, if theta not in region

\end{fulllineitems}

\index{locate() (mpo.upop.point\_location.PointLocation method)@\spxentry{locate()}\spxextra{mpo.upop.point\_location.PointLocation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.point_location.PointLocation.locate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{locate}}}{\emph{\DUrole{n}{theta}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ int}}
\sphinxAtStartPar
Finds the index of the critical region that theta is inside
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{theta}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{mpo.upop.ucontroller module}
\label{\detokenize{mpo.upop:module-mpo.upop.ucontroller}}\label{\detokenize{mpo.upop:mpo-upop-ucontroller-module}}\index{module@\spxentry{module}!mpo.upop.ucontroller@\spxentry{mpo.upop.ucontroller}}\index{mpo.upop.ucontroller@\spxentry{mpo.upop.ucontroller}!module@\spxentry{module}}\index{BVH (class in mpo.upop.ucontroller)@\spxentry{BVH}\spxextra{class in mpo.upop.ucontroller}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.ucontroller.BVH}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mpo.upop.ucontroller.}}\sphinxbfcode{\sphinxupquote{BVH}}}{\emph{\DUrole{n}{parent}}, \emph{\DUrole{n}{fundamental\_list}}, \emph{\DUrole{n}{region\_list}}, \emph{\DUrole{n}{depth}}, \emph{\DUrole{n}{index}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\end{fulllineitems}

\index{classify\_polytope() (in module mpo.upop.ucontroller)@\spxentry{classify\_polytope()}\spxextra{in module mpo.upop.ucontroller}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.ucontroller.classify_polytope}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.upop.ucontroller.}}\sphinxbfcode{\sphinxupquote{classify\_polytope}}}{\emph{\DUrole{n}{region}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.critical_region.CriticalRegion}]{\sphinxcrossref{mpo.critical\_region.CriticalRegion}}}}}, \emph{\DUrole{n}{hyper\_plane}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ int}}
\sphinxAtStartPar
We are going to classify the polytopic critical region by solving 2 LPS

\sphinxAtStartPar
max ||\textless{}x,A\textgreater{}||\sphinxhyphen{}d for x in Critical region

\sphinxAtStartPar
min ||\textless{}x,A\textgreater{}||\sphinxhyphen{}d for x in Critical region

\sphinxAtStartPar
The result of the objective function will tell us the side of the hyper plane the point is on
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{region}} \textendash{} Critical region

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hyper\_plane}} \textendash{} A fundamental hyperplane

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxhyphen{}1 if completely not in support, 0 if intersected, 1 if completely in support

\end{description}\end{quote}

\end{fulllineitems}

\index{determine\_hyperplane() (in module mpo.upop.ucontroller)@\spxentry{determine\_hyperplane()}\spxextra{in module mpo.upop.ucontroller}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.ucontroller.determine_hyperplane}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.upop.ucontroller.}}\sphinxbfcode{\sphinxupquote{determine\_hyperplane}}}{\emph{\DUrole{n}{regions}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{mpo:mpo.critical_region.CriticalRegion}]{\sphinxcrossref{mpo.critical\_region.CriticalRegion}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{hyper\_planes}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{}
\sphinxAtStartPar
Finds the ‘best’ splitting hyper plane for this task

\sphinxAtStartPar
In this case best means minimizing the number of intersected regions while also maximizing the difference between supported and not supported regions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{regions}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hyper\_planes}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
{[}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_code() (in module mpo.upop.ucontroller)@\spxentry{generate\_code()}\spxextra{in module mpo.upop.ucontroller}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.ucontroller.generate_code}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.upop.ucontroller.}}\sphinxbfcode{\sphinxupquote{generate\_code}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.solution.Solution}]{\sphinxcrossref{mpo.solution.Solution}}}}}}{{ $\rightarrow$ List\DUrole{p}{{[}}str\DUrole{p}{{]}}}}
\sphinxAtStartPar
Generates C++17 code for point location and function evaluation on microcontrollers

\sphinxAtStartPar
This forms a BVH to accelerate solution times

\sphinxAtStartPar
WARNING: This breaks down at high dimensions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} a solution to a MPLP or MPQP solution

\item[{Returns}] \leavevmode
\sphinxAtStartPar
List of the strings of the C++17 datafiles that integrate with uPOP

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{mpo.upop.upop\_utils module}
\label{\detokenize{mpo.upop:module-mpo.upop.upop_utils}}\label{\detokenize{mpo.upop:mpo-upop-upop-utils-module}}\index{module@\spxentry{module}!mpo.upop.upop\_utils@\spxentry{mpo.upop.upop\_utils}}\index{mpo.upop.upop\_utils@\spxentry{mpo.upop.upop\_utils}!module@\spxentry{module}}\index{find\_unique\_hyperplanes() (in module mpo.upop.upop\_utils)@\spxentry{find\_unique\_hyperplanes()}\spxextra{in module mpo.upop.upop\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.upop_utils.find_unique_hyperplanes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.upop.upop\_utils.}}\sphinxbfcode{\sphinxupquote{find\_unique\_hyperplanes}}}{\emph{\DUrole{n}{overall}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ Tuple\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
Generates the list of indices of the fundamental hyperplanes of the solution, as well as the indices of the associated hyperplanes from the original solution and the parity of the constraint

\sphinxAtStartPar
This is linear w.r.t. number of hyper planes and is quite quick \textasciitilde{}25 ns per constraint in the solution

\sphinxAtStartPar
It first creates approximate(near exact) integer representations for each constraint for each region in the solution

\sphinxAtStartPar
This approximation step is justified in that it will find equality between 2 constraints if the L2 norm of the difference is below 10E\sphinxhyphen{}12

\sphinxAtStartPar
Then the positive and negative versions of these constraints {[} \sphinxhyphen{}x \textless{} \sphinxhyphen{}1, x \textless{} 1 are on different sides of the same hyperplane{]} are made into a format that can be hashed (tuples of ints)

\sphinxAtStartPar
With this is is relatively strait forward to check for uniqueness with the set

\sphinxAtStartPar
The first loop scans thru all of the constraints and if the constraint contains a unique hyperplane
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
if it is a unique hyper plane store the index, add the integer representation to the set, then index the integer representation to the index

\item {} 
\sphinxAtStartPar
if it is not a unique hyperplane do nothing

\end{enumerate}

\sphinxAtStartPar
The second loop scans thru the constraints again and assigns them unique hyper plane indices and the parity(what side of the hyper plane that they are on)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{overall}} \textendash{} The solution of a multiparametric programming problem

\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns indices of fundamental hyperplanes, indices of constraints back to fundamental hyperplane, parity of constraint

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_unique\_region\_functions() (in module mpo.upop.upop\_utils)@\spxentry{find\_unique\_region\_functions()}\spxextra{in module mpo.upop.upop\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.upop_utils.find_unique_region_functions}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.upop.upop\_utils.}}\sphinxbfcode{\sphinxupquote{find\_unique\_region\_functions}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.solution.Solution}]{\sphinxcrossref{mpo.solution.Solution}}}}}}{{ $\rightarrow$ Tuple\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\end{fulllineitems}

\index{find\_unique\_region\_hyperplanes() (in module mpo.upop.upop\_utils)@\spxentry{find\_unique\_region\_hyperplanes()}\spxextra{in module mpo.upop.upop\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.upop_utils.find_unique_region_hyperplanes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.upop.upop\_utils.}}\sphinxbfcode{\sphinxupquote{find\_unique\_region\_hyperplanes}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.solution.Solution}]{\sphinxcrossref{mpo.solution.Solution}}}}}}{{ $\rightarrow$ Tuple\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
This is an overload of the find\_unique\_hyperplane function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_chebychev\_centers() (in module mpo.upop.upop\_utils)@\spxentry{get\_chebychev\_centers()}\spxextra{in module mpo.upop.upop\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.upop_utils.get_chebychev_centers}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.upop.upop\_utils.}}\sphinxbfcode{\sphinxupquote{get\_chebychev\_centers}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.solution.Solution}]{\sphinxcrossref{mpo.solution.Solution}}}}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Calculates and returns a list of all of the theta chebychev centers for the critical regions in the solution
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} An mp programming Solution

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A list of all of the chebychev centers of the regions in the solutions

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_descriptions() (in module mpo.upop.upop\_utils)@\spxentry{get\_descriptions()}\spxextra{in module mpo.upop.upop\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.upop_utils.get_descriptions}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.upop.upop\_utils.}}\sphinxbfcode{\sphinxupquote{get\_descriptions}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.solution.Solution}]{\sphinxcrossref{mpo.solution.Solution}}}}}}{{ $\rightarrow$ dict}}
\end{fulllineitems}

\index{get\_outer\_boundaries() (in module mpo.upop.upop\_utils)@\spxentry{get\_outer\_boundaries()}\spxextra{in module mpo.upop.upop\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.upop_utils.get_outer_boundaries}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.upop.upop\_utils.}}\sphinxbfcode{\sphinxupquote{get\_outer\_boundaries}}}{\emph{\DUrole{n}{indices}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{parity}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
Takes in the global constraint indices to the fundamental hyperplanes and their parity finds all planes with only one parity version aka only one verity of them appears in the original set.

\sphinxAtStartPar
This method is linear w.r.t. number of indices, by the use of sets and hash maps
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{indices}} \textendash{} list of indices that maps the solution constraints into the fundamental hyperplanes

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parity}} \textendash{} the side of the hyperplane that the constraint represents

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{verify\_outer\_boundary() (in module mpo.upop.upop\_utils)@\spxentry{verify\_outer\_boundary()}\spxextra{in module mpo.upop.upop\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.upop:mpo.upop.upop_utils.verify_outer_boundary}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.upop.upop\_utils.}}\sphinxbfcode{\sphinxupquote{verify\_outer\_boundary}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.solution.Solution}]{\sphinxcrossref{mpo.solution.Solution}}}}}, \emph{\DUrole{n}{hyper\_indices}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{outer\_indices}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{chebychev\_centers}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}
\sphinxAtStartPar
This checks all of the possible outer boundary indices for errors, failures to solve for the minimal set of fundamental hyperplanes in the solution
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} An mp programming solution

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hyper\_indices}} \textendash{} The list of all fundamental hyperplane indices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{outer\_indices}} \textendash{} The list of identified exterior hyperplane indices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{chebychev\_centers}} \textendash{} the list of chebychev centers in the theta space for every critical region \{Optional\}

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
List of verified outer boundary constraints

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{mpo.upop:module-mpo.upop}}\label{\detokenize{mpo.upop:module-contents}}\index{module@\spxentry{module}!mpo.upop@\spxentry{mpo.upop}}\index{mpo.upop@\spxentry{mpo.upop}!module@\spxentry{module}}

\subsubsection{mpo.utils package}
\label{\detokenize{mpo.utils:mpo-utils-package}}\label{\detokenize{mpo.utils::doc}}

\paragraph{Submodules}
\label{\detokenize{mpo.utils:submodules}}

\paragraph{mpo.utils.chebyshev\_ball module}
\label{\detokenize{mpo.utils:module-mpo.utils.chebyshev_ball}}\label{\detokenize{mpo.utils:mpo-utils-chebyshev-ball-module}}\index{module@\spxentry{module}!mpo.utils.chebyshev\_ball@\spxentry{mpo.utils.chebyshev\_ball}}\index{mpo.utils.chebyshev\_ball@\spxentry{mpo.utils.chebyshev\_ball}!module@\spxentry{module}}\index{chebyshev\_ball() (in module mpo.utils.chebyshev\_ball)@\spxentry{chebyshev\_ball()}\spxextra{in module mpo.utils.chebyshev\_ball}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.chebyshev_ball.chebyshev_ball}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.chebyshev\_ball.}}\sphinxbfcode{\sphinxupquote{chebyshev\_ball}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{equality\_constraints}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{bin\_vars}\DUrole{p}{:} \DUrole{n}{Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{()}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}glpk\textquotesingle{}}}}{}
\sphinxAtStartPar
Chebyshev ball finds the largest ball inside of a polytope defined by Ax \textless{}= b
This is solved by the following LP

\sphinxAtStartPar
min\{x,r\} \sphinxhyphen{}r
\begin{description}
\item[{st:}] \leavevmode
\sphinxAtStartPar
Ax + ||A\_i||r \textless{}= b

\sphinxAtStartPar
A\_\{eq\}*x = b\_\{eq\}

\sphinxAtStartPar
r \textgreater{}=0

\end{description}

\sphinxAtStartPar
Returns a List with {[}pos, r{]}
where pos is a numpy array
r is a real number
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} LHS Constraint Matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} RHS Constraint column vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{equality\_constraints}} \textendash{} indices of

\end{itemize}

\end{description}\end{quote}

\sphinxAtStartPar
rows that have strict equality A{[}eq{]} @ x = b{[}eq{]}
:param bin\_vars: indices of binary variables
:param deterministic\_solver: The underlying Solver to use, eg. gurobi, ect
:return: the optimization output of the LP problem, the coordinates can be found in output{[}‘sol’{]}, with output{[}‘sol’{]}{[}\sphinxhyphen{}1{]}
giving the chebyshev radius

\end{fulllineitems}



\paragraph{mpo.utils.constraint\_utilities module}
\label{\detokenize{mpo.utils:module-mpo.utils.constraint_utilities}}\label{\detokenize{mpo.utils:mpo-utils-constraint-utilities-module}}\index{module@\spxentry{module}!mpo.utils.constraint\_utilities@\spxentry{mpo.utils.constraint\_utilities}}\index{mpo.utils.constraint\_utilities@\spxentry{mpo.utils.constraint\_utilities}!module@\spxentry{module}}\index{calculate\_redundant\_constraints() (in module mpo.utils.constraint\_utilities)@\spxentry{calculate\_redundant\_constraints()}\spxextra{in module mpo.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.constraint_utilities.calculate_redundant_constraints}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{calculate\_redundant\_constraints}}}{\emph{\DUrole{n}{A}}, \emph{\DUrole{n}{b}}}{}
\sphinxAtStartPar
Removes weakly redundant constraints, method is from the appendix of the Oberdieck paper

\sphinxAtStartPar
url: \sphinxurl{https://www.sciencedirect.com/science/article/pii/S0005109816303971}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} LHS constraint matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} RHS constraint column vector

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The processes constraint pair {[}A, b{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{cheap\_remove\_redundant\_constraints() (in module mpo.utils.constraint\_utilities)@\spxentry{cheap\_remove\_redundant\_constraints()}\spxextra{in module mpo.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.constraint_utilities.cheap_remove_redundant_constraints}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{cheap\_remove\_redundant\_constraints}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Removes zero rows, normalizes the constraint rows to ||A\_i||\_\{L\_2\} = 1, and removes duplicate rows
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} LHS constraint matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} RHS constraint column vector

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The processes constraint pair {[}A, b{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{constraint\_norm() (in module mpo.utils.constraint\_utilities)@\spxentry{constraint\_norm()}\spxextra{in module mpo.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.constraint_utilities.constraint_norm}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{constraint\_norm}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Finds the L2 norm of each row of a matrix
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} numpy matrix

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A column vector of the row norms

\end{description}\end{quote}

\end{fulllineitems}

\index{facet\_ball\_elimination() (in module mpo.utils.constraint\_utilities)@\spxentry{facet\_ball\_elimination()}\spxextra{in module mpo.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.constraint_utilities.facet_ball_elimination}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{facet\_ball\_elimination}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Removes weakly redundant constraints, method is from the appendix of the Oberdieck paper

\sphinxAtStartPar
url: \sphinxurl{https://www.sciencedirect.com/science/article/pii/S0005109816303971}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} LHS constraint matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} RHS constraint column vector

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The processes constraint pair {[}A, b{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_full\_rank() (in module mpo.utils.constraint\_utilities)@\spxentry{is\_full\_rank()}\spxextra{in module mpo.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.constraint_utilities.is_full_rank}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{is\_full\_rank}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{indices}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ bool}}
\sphinxAtStartPar
Tests if the matrix A{[}indices{]} is full rank
Empty matrices e.g. A{[}{[}{]}{]} will default to be full rank
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} Matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{indices}} \textendash{} indices to consider in rank

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
if the matrix is full rank or not

\end{description}\end{quote}

\end{fulllineitems}

\index{process\_region\_constraints() (in module mpo.utils.constraint\_utilities)@\spxentry{process\_region\_constraints()}\spxextra{in module mpo.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.constraint_utilities.process_region_constraints}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{process\_region\_constraints}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Removes all strongly and weakly redundant constraints
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} LHS constraint matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} RHS constraint column vector

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The processes constraint pair {[}A, b{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_duplicate\_rows() (in module mpo.utils.constraint\_utilities)@\spxentry{remove\_duplicate\_rows()}\spxextra{in module mpo.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.constraint_utilities.remove_duplicate_rows}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{remove\_duplicate\_rows}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Finds and removes duplicate rows in the constraints A @ x \textless{}= b

\end{fulllineitems}

\index{remove\_strongly\_redundant\_constraints() (in module mpo.utils.constraint\_utilities)@\spxentry{remove\_strongly\_redundant\_constraints()}\spxextra{in module mpo.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.constraint_utilities.remove_strongly_redundant_constraints}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{remove\_strongly\_redundant\_constraints}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Removes strongly redundant constraints by testing the feasibility of each constraint if activated

\end{fulllineitems}

\index{remove\_zero\_rows() (in module mpo.utils.constraint\_utilities)@\spxentry{remove\_zero\_rows()}\spxextra{in module mpo.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.constraint_utilities.remove_zero_rows}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{remove\_zero\_rows}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Finds rows equal to zero in A and then removes them from A and b
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} LHS Matrix constraint

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} RHS Column vector

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a list{[}A\_cleaned, b\_cleaned{]} of filtered constraints

\end{description}\end{quote}

\end{fulllineitems}

\index{row\_equality() (in module mpo.utils.constraint\_utilities)@\spxentry{row\_equality()}\spxextra{in module mpo.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.constraint_utilities.row_equality}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{row\_equality}}}{\emph{\DUrole{n}{row\_1}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{row\_2}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{tol}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}16}}}{{ $\rightarrow$ bool}}
\sphinxAtStartPar
Tests if 2 row vectors are approximately equal
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{row\_1}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{row\_2}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tol}} \textendash{} tolerable L2 norm of the difference

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
True if rows are equal

\end{description}\end{quote}

\end{fulllineitems}

\index{scale\_constraint() (in module mpo.utils.constraint\_utilities)@\spxentry{scale\_constraint()}\spxextra{in module mpo.utils.constraint\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.constraint_utilities.scale_constraint}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.constraint\_utilities.}}\sphinxbfcode{\sphinxupquote{scale\_constraint}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Normalizes constraints
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} LHS Matrix constraint

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} RHS column vector constraint

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a list {[}A\_scaled, b\_scaled{]} of normalized constraints

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{mpo.utils.general\_utils module}
\label{\detokenize{mpo.utils:module-mpo.utils.general_utils}}\label{\detokenize{mpo.utils:mpo-utils-general-utils-module}}\index{module@\spxentry{module}!mpo.utils.general\_utils@\spxentry{mpo.utils.general\_utils}}\index{mpo.utils.general\_utils@\spxentry{mpo.utils.general\_utils}!module@\spxentry{module}}\index{latex\_matrix() (in module mpo.utils.general\_utils)@\spxentry{latex\_matrix()}\spxextra{in module mpo.utils.general\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.general_utils.latex_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.general\_utils.}}\sphinxbfcode{\sphinxupquote{latex\_matrix}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}List\DUrole{p}{{[}}str\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}{{ $\rightarrow$ str}}
\sphinxAtStartPar
Creates a latex string for a given numpy array
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} A numpy array

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A latex string for the matrix A

\end{description}\end{quote}

\end{fulllineitems}

\index{make\_column() (in module mpo.utils.general\_utils)@\spxentry{make\_column()}\spxextra{in module mpo.utils.general\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.general_utils.make_column}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.general\_utils.}}\sphinxbfcode{\sphinxupquote{make\_column}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}List\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Makes x into a column vector
:param x: a list or a numpy array
:return: a numpy array that is a column vector

\end{fulllineitems}

\index{make\_row() (in module mpo.utils.general\_utils)@\spxentry{make\_row()}\spxextra{in module mpo.utils.general\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.general_utils.make_row}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.general\_utils.}}\sphinxbfcode{\sphinxupquote{make\_row}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}List\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Makes x into a row vector
:param x: a list or a numpy array
:return: a numpy array that is a row column

\end{fulllineitems}

\index{mpo\_block() (in module mpo.utils.general\_utils)@\spxentry{mpo\_block()}\spxextra{in module mpo.utils.general\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.general_utils.mpo_block}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.general\_utils.}}\sphinxbfcode{\sphinxupquote{mpo\_block}}}{\emph{\DUrole{n}{mat\_list}}}{}
\end{fulllineitems}

\index{num\_cpu\_cores() (in module mpo.utils.general\_utils)@\spxentry{num\_cpu\_cores()}\spxextra{in module mpo.utils.general\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.general_utils.num_cpu_cores}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.general\_utils.}}\sphinxbfcode{\sphinxupquote{num\_cpu\_cores}}}{}{}
\sphinxAtStartPar
Finds the number of allocated cores,with different behavior in windows and linux.

\sphinxAtStartPar
In Windows, returns number of physical cpu cores

\sphinxAtStartPar
In Linux, returns number of available cores for processing (this is for running on cluster or managed environment)
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
number of cores

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_size\_zero\_matrices() (in module mpo.utils.general\_utils)@\spxentry{remove\_size\_zero\_matrices()}\spxextra{in module mpo.utils.general\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.general_utils.remove_size_zero_matrices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.general\_utils.}}\sphinxbfcode{\sphinxupquote{remove\_size\_zero\_matrices}}}{\emph{\DUrole{n}{list\_matrices}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Removes size zero matrices from a list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_matrices}} \textendash{} A list of numpy arrays

\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns all matrices from the list that do not have a dimension of 0 in any index

\end{description}\end{quote}

\end{fulllineitems}

\index{select\_not\_in\_list() (in module mpo.utils.general\_utils)@\spxentry{select\_not\_in\_list()}\spxextra{in module mpo.utils.general\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.general_utils.select_not_in_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.general\_utils.}}\sphinxbfcode{\sphinxupquote{select\_not\_in\_list}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{list\_}\DUrole{p}{:} \DUrole{n}{Iterable\DUrole{p}{{[}}int\DUrole{p}{{]}}}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Filters a numpy array to select all rows that are not in a list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{A}} \textendash{} a numpy array

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list}} \textendash{} a list of indices that you want to remove

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
return a numpy array of A{[}not in {\color{red}\bfseries{}list\_}{]}

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{mpo.utils.geometric module}
\label{\detokenize{mpo.utils:module-mpo.utils.geometric}}\label{\detokenize{mpo.utils:mpo-utils-geometric-module}}\index{module@\spxentry{module}!mpo.utils.geometric@\spxentry{mpo.utils.geometric}}\index{mpo.utils.geometric@\spxentry{mpo.utils.geometric}!module@\spxentry{module}}\index{gen\_tess\_points\_simplex() (in module mpo.utils.geometric)@\spxentry{gen\_tess\_points\_simplex()}\spxextra{in module mpo.utils.geometric}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.geometric.gen_tess_points_simplex}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.geometric.}}\sphinxbfcode{\sphinxupquote{gen\_tess\_points\_simplex}}}{\emph{\DUrole{n}{simplex}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{simplex}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{make\_domain\_subdivision() (in module mpo.utils.geometric)@\spxentry{make\_domain\_subdivision()}\spxextra{in module mpo.utils.geometric}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.geometric.make_domain_subdivision}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.geometric.}}\sphinxbfcode{\sphinxupquote{make\_domain\_subdivision}}}{\emph{\DUrole{n}{A\_t}}, \emph{\DUrole{n}{b\_t}}}{}
\end{fulllineitems}

\index{make\_simplex() (in module mpo.utils.geometric)@\spxentry{make\_simplex()}\spxextra{in module mpo.utils.geometric}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.geometric.make_simplex}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.geometric.}}\sphinxbfcode{\sphinxupquote{make\_simplex}}}{\emph{\DUrole{n}{n}\DUrole{p}{:} \DUrole{n}{int}}}{}
\end{fulllineitems}

\index{make\_subdomains() (in module mpo.utils.geometric)@\spxentry{make\_subdomains()}\spxextra{in module mpo.utils.geometric}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.geometric.make_subdomains}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.geometric.}}\sphinxbfcode{\sphinxupquote{make\_subdomains}}}{\emph{\DUrole{n}{points}}}{}
\end{fulllineitems}

\index{revised\_tess\_simplex() (in module mpo.utils.geometric)@\spxentry{revised\_tess\_simplex()}\spxextra{in module mpo.utils.geometric}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.geometric.revised_tess_simplex}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.geometric.}}\sphinxbfcode{\sphinxupquote{revised\_tess\_simplex}}}{\emph{\DUrole{n}{simplex}}, \emph{\DUrole{n}{half\_split}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\end{fulllineitems}



\paragraph{mpo.utils.mpqp\_utils module}
\label{\detokenize{mpo.utils:module-mpo.utils.mpqp_utils}}\label{\detokenize{mpo.utils:mpo-utils-mpqp-utils-module}}\index{module@\spxentry{module}!mpo.utils.mpqp\_utils@\spxentry{mpo.utils.mpqp\_utils}}\index{mpo.utils.mpqp\_utils@\spxentry{mpo.utils.mpqp\_utils}!module@\spxentry{module}}\index{calculate\_control\_law() (in module mpo.utils.mpqp\_utils)@\spxentry{calculate\_control\_law()}\spxextra{in module mpo.utils.mpqp\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.mpqp_utils.calculate_control_law}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.mpqp\_utils.}}\sphinxbfcode{\sphinxupquote{calculate\_control\_law}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}}{{ $\rightarrow$ Tuple}}
\end{fulllineitems}

\index{check\_feasibility() (in module mpo.utils.mpqp\_utils)@\spxentry{check\_feasibility()}\spxextra{in module mpo.utils.mpqp\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.mpqp_utils.check_feasibility}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.mpqp\_utils.}}\sphinxbfcode{\sphinxupquote{check\_feasibility}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{active\_set}}}{}
\end{fulllineitems}

\index{check\_optimality() (in module mpo.utils.mpqp\_utils)@\spxentry{check\_optimality()}\spxextra{in module mpo.utils.mpqp\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.mpqp_utils.check_optimality}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.mpqp\_utils.}}\sphinxbfcode{\sphinxupquote{check\_optimality}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{list}}}{}
\sphinxAtStartPar
Tests if the active set is optimal for the provided mpqp program
\begin{quote}
\begin{description}
\item[{x | theta | lambda | slack | t}] \leavevmode
\sphinxAtStartPar
max t
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
Qu + (A\_Ai)\textasciicircum{}T lambda\_Ai + c = 0

\item {} 
\sphinxAtStartPar
A\_Ai*u \sphinxhyphen{} b\_ai\sphinxhyphen{}F\_ai*theta = 0

\item {} 
\sphinxAtStartPar
A\_Aj*u \sphinxhyphen{} b\_aj\sphinxhyphen{}F\_aj*theta + sj\_k= 0

\item {} 
\sphinxAtStartPar
t*e\_1 \textless{}= lambda\_Ai,

\item {} 
\sphinxAtStartPar
t*e\_2 \textless{}= s\_Ji

\item {} 
\sphinxAtStartPar
t \textgreater{}= 0,

\item {} 
\sphinxAtStartPar
lambda\_Ai\textgreater{}= 0,

\item {} 
\sphinxAtStartPar
s\_Ji\textgreater{}=0

\item {} 
\sphinxAtStartPar
A\_t*theta\textless{}= b\_t

\end{enumerate}

\end{description}
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} an mpqp program

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{active\_set}} \textendash{} active set being considered in the optimality test

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
dictionary of parameters, or None if active set is not optimal

\end{description}\end{quote}

\end{fulllineitems}

\index{gen\_cr\_from\_active\_set() (in module mpo.utils.mpqp\_utils)@\spxentry{gen\_cr\_from\_active\_set()}\spxextra{in module mpo.utils.mpqp\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.mpqp_utils.gen_cr_from_active_set}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.mpqp\_utils.}}\sphinxbfcode{\sphinxupquote{gen\_cr\_from\_active\_set}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}}}, \emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{check\_full\_dim}\DUrole{o}{=}\DUrole{default_value}{True}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{mpo:mpo.critical_region.CriticalRegion}]{\sphinxcrossref{mpo.critical\_region.CriticalRegion}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
Builds the critical region of the given mpqp from the active set.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} the MQMP\_Program to be solved

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{active\_set}} \textendash{} the active set combination to build this critical region from

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{check\_full\_dim}} \textendash{} Keyword Arg, if true will return null if the region has lower dimensionality

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Returns the associated critical region if fully dimensional else returns None

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_boundary\_types() (in module mpo.utils.mpqp\_utils)@\spxentry{get\_boundary\_types()}\spxextra{in module mpo.utils.mpqp\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.mpqp_utils.get_boundary_types}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.mpqp\_utils.}}\sphinxbfcode{\sphinxupquote{get\_boundary\_types}}}{\emph{\DUrole{n}{region}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{omega}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{lagrange}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{regular}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ List}}
\sphinxAtStartPar
Classifies the boundaries of a polytope into Omega constraints, Lagrange multiplier = 0 constraints, and Activated program constraints
:param region:
:param omega:
:param lagrange:
:param regular:
:return:

\end{fulllineitems}

\index{get\_feasible\_theta() (in module mpo.utils.mpqp\_utils)@\spxentry{get\_feasible\_theta()}\spxextra{in module mpo.utils.mpqp\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.mpqp_utils.get_feasible_theta}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.mpqp\_utils.}}\sphinxbfcode{\sphinxupquote{get\_feasible\_theta}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}None\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}
\end{fulllineitems}

\index{get\_feasible\_theta\_2() (in module mpo.utils.mpqp\_utils)@\spxentry{get\_feasible\_theta\_2()}\spxextra{in module mpo.utils.mpqp\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.mpqp_utils.get_feasible_theta_2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.mpqp\_utils.}}\sphinxbfcode{\sphinxupquote{get\_feasible\_theta\_2}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}None\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Finds a feasible theta constraint of the multi\sphinxhyphen{}parametric problem

\sphinxAtStartPar
Pseudo\sphinxhyphen{}Code Steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
Find and calculate the Theta Ball of the theta feasible space

\item {} 
\sphinxAtStartPar
See if the center of the ball is a valid theta point

\item {} 
\sphinxAtStartPar
if not retry up to \{100\} times to find a feasible point in the theta ball of the problem

\item {} 
\sphinxAtStartPar
If one can not be found in the theta ball returns None

\end{enumerate}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} MP Program

\item[{Returns}] \leavevmode
\sphinxAtStartPar
feasible theta point or None

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_region() (in module mpo.utils.mpqp\_utils)@\spxentry{get\_region()}\spxextra{in module mpo.utils.mpqp\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.mpqp_utils.get_region}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.mpqp\_utils.}}\sphinxbfcode{\sphinxupquote{get\_region}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{mpo:mpo.critical_region.CriticalRegion}]{\sphinxcrossref{mpo.critical\_region.CriticalRegion}}}}}
\end{fulllineitems}

\index{is\_full\_dimensional() (in module mpo.utils.mpqp\_utils)@\spxentry{is\_full\_dimensional()}\spxextra{in module mpo.utils.mpqp\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.mpqp_utils.is_full_dimensional}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.mpqp\_utils.}}\sphinxbfcode{\sphinxupquote{is\_full\_dimensional}}}{\emph{\DUrole{n}{A}}, \emph{\DUrole{n}{b}}}{}
\end{fulllineitems}

\index{theta\_ball() (in module mpo.utils.mpqp\_utils)@\spxentry{theta\_ball()}\spxextra{in module mpo.utils.mpqp\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.mpqp_utils.theta_ball}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.mpqp\_utils.}}\sphinxbfcode{\sphinxupquote{theta\_ball}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput}]{\sphinxcrossref{mpo.Solver\_interface.Solver\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
Finds the chebychev ball in the theta feasible space of a problem.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{program}} \textendash{} MPQP\_Program

\item[{Returns}] \leavevmode
\sphinxAtStartPar
basic result from the LP

\end{description}\end{quote}

\end{fulllineitems}

\index{zeros() (in module mpo.utils.mpqp\_utils)@\spxentry{zeros()}\spxextra{in module mpo.utils.mpqp\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.mpqp_utils.zeros}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.mpqp\_utils.}}\sphinxbfcode{\sphinxupquote{zeros}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{y}\DUrole{p}{:} \DUrole{n}{int}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Auxiliary function returns a numpy array of zeros of dimensions x by y (rows, columns)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} Number of rows

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} Number of Columns

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Numpy array of zeros

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{mpo.utils.Solver\_utils module}
\label{\detokenize{mpo.utils:module-mpo.utils.solver_utils}}\label{\detokenize{mpo.utils:mpo-utils-Solver-utils-module}}\index{module@\spxentry{module}!mpo.utils.Solver\_utils@\spxentry{mpo.utils.Solver\_utils}}\index{mpo.utils.Solver\_utils@\spxentry{mpo.utils.Solver\_utils}!module@\spxentry{module}}\index{get\_active\_set() (in module mpo.utils.Solver\_utils)@\spxentry{get\_active\_set()}\spxextra{in module mpo.utils.Solver\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo.utils:mpo.utils.solver_utils.get_active_set}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.utils.Solver\_utils.}}\sphinxbfcode{\sphinxupquote{get\_active\_set}}}{\emph{\DUrole{n}{soln}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput}]{\sphinxcrossref{mpo.Solver\_interface.Solver\_utils.SolverOutput}}}}}}{{ $\rightarrow$ numpy.array}}
\sphinxAtStartPar
finds the active set of a problem output
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{soln}} \textendash{} dict results from the Solver interface

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the active set of a solution

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{mpo.utils:module-mpo.utils}}\label{\detokenize{mpo.utils:module-contents}}\index{module@\spxentry{module}!mpo.utils@\spxentry{mpo.utils}}\index{mpo.utils@\spxentry{mpo.utils}!module@\spxentry{module}}

\subsection{Submodules}
\label{\detokenize{mpo:submodules}}

\subsection{mpo.critical\_region module}
\label{\detokenize{mpo:module-mpo.critical_region}}\label{\detokenize{mpo:mpo-critical-region-module}}\index{module@\spxentry{module}!mpo.critical\_region@\spxentry{mpo.critical\_region}}\index{mpo.critical\_region@\spxentry{mpo.critical\_region}!module@\spxentry{module}}\index{CriticalRegion (class in mpo.critical\_region)@\spxentry{CriticalRegion}\spxextra{class in mpo.critical\_region}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.critical_region.CriticalRegion}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mpo.critical\_region.}}\sphinxbfcode{\sphinxupquote{CriticalRegion}}}{\emph{A: numpy.ndarray, b: numpy.ndarray, C: numpy.ndarray, d: numpy.ndarray, E: numpy.ndarray, f: numpy.ndarray, active\_set: Union{[}List{[}int{]}, numpy.ndarray{]}, omega\_set: Union{[}List{[}int{]}, numpy.ndarray{]} = \textless{}factory\textgreater{}, lambda\_set: Union{[}List{[}int{]}, numpy.ndarray{]} = \textless{}factory\textgreater{}, regular\_set: Union{[}List{[}int{]}, numpy.ndarray{]} = \textless{}factory\textgreater{}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Critical region is a polytope that defines a region in the uncertainty space
with an associated optimal value, active set, lagrange multipliers and
constraints

\sphinxAtStartPar
x(θ) = Aθ + b

\sphinxAtStartPar
λ(θ) = Cθ + d

\sphinxAtStartPar
CR := \{θ : Eθ \textless{}= f\}

\sphinxAtStartPar
active\_set: numpy array of indices

\sphinxAtStartPar
constraint\_set: if this is a A@x = b + \sphinxhref{mailto:F@theta}{F@theta} boundary

\sphinxAtStartPar
lambda\_set: if this is a λ = 0 boundary

\sphinxAtStartPar
boundary\_set: if this is a Eθ \textless{}= f boundary
\index{A (mpo.critical\_region.CriticalRegion attribute)@\spxentry{A}\spxextra{mpo.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.critical_region.CriticalRegion.A}}\pysigline{\sphinxbfcode{\sphinxupquote{A}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{C (mpo.critical\_region.CriticalRegion attribute)@\spxentry{C}\spxextra{mpo.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.critical_region.CriticalRegion.C}}\pysigline{\sphinxbfcode{\sphinxupquote{C}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{E (mpo.critical\_region.CriticalRegion attribute)@\spxentry{E}\spxextra{mpo.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.critical_region.CriticalRegion.E}}\pysigline{\sphinxbfcode{\sphinxupquote{E}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{active\_set (mpo.critical\_region.CriticalRegion attribute)@\spxentry{active\_set}\spxextra{mpo.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.critical_region.CriticalRegion.active_set}}\pysigline{\sphinxbfcode{\sphinxupquote{active\_set}}\sphinxbfcode{\sphinxupquote{: Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{b (mpo.critical\_region.CriticalRegion attribute)@\spxentry{b}\spxextra{mpo.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.critical_region.CriticalRegion.b}}\pysigline{\sphinxbfcode{\sphinxupquote{b}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{d (mpo.critical\_region.CriticalRegion attribute)@\spxentry{d}\spxextra{mpo.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.critical_region.CriticalRegion.d}}\pysigline{\sphinxbfcode{\sphinxupquote{d}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{evaluate() (mpo.critical\_region.CriticalRegion method)@\spxentry{evaluate()}\spxextra{mpo.critical\_region.CriticalRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.critical_region.CriticalRegion.evaluate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{evaluate}}}{\emph{\DUrole{n}{theta}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Evaluates x(θ) = Aθ + b

\end{fulllineitems}

\index{f (mpo.critical\_region.CriticalRegion attribute)@\spxentry{f}\spxextra{mpo.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.critical_region.CriticalRegion.f}}\pysigline{\sphinxbfcode{\sphinxupquote{f}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{get\_constraints() (mpo.critical\_region.CriticalRegion method)@\spxentry{get\_constraints()}\spxextra{mpo.critical\_region.CriticalRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.critical_region.CriticalRegion.get_constraints}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_constraints}}}{}{}
\end{fulllineitems}

\index{is\_full\_dimension() (mpo.critical\_region.CriticalRegion method)@\spxentry{is\_full\_dimension()}\spxextra{mpo.critical\_region.CriticalRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.critical_region.CriticalRegion.is_full_dimension}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_full\_dimension}}}{}{{ $\rightarrow$ bool}}
\sphinxAtStartPar
Tests dimensionality of critical region

\end{fulllineitems}

\index{is\_inside() (mpo.critical\_region.CriticalRegion method)@\spxentry{is\_inside()}\spxextra{mpo.critical\_region.CriticalRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.critical_region.CriticalRegion.is_inside}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_inside}}}{\emph{\DUrole{n}{theta}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Tests if point θ is inside of the critical region

\end{fulllineitems}

\index{lagrange\_multipliers() (mpo.critical\_region.CriticalRegion method)@\spxentry{lagrange\_multipliers()}\spxextra{mpo.critical\_region.CriticalRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.critical_region.CriticalRegion.lagrange_multipliers}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{lagrange\_multipliers}}}{\emph{\DUrole{n}{theta}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
\sphinxAtStartPar
Evaluates λ(θ) = Cθ + d

\end{fulllineitems}

\index{lambda\_set (mpo.critical\_region.CriticalRegion attribute)@\spxentry{lambda\_set}\spxextra{mpo.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.critical_region.CriticalRegion.lambda_set}}\pysigline{\sphinxbfcode{\sphinxupquote{lambda\_set}}\sphinxbfcode{\sphinxupquote{: Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{omega\_set (mpo.critical\_region.CriticalRegion attribute)@\spxentry{omega\_set}\spxextra{mpo.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.critical_region.CriticalRegion.omega_set}}\pysigline{\sphinxbfcode{\sphinxupquote{omega\_set}}\sphinxbfcode{\sphinxupquote{: Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{regular\_set (mpo.critical\_region.CriticalRegion attribute)@\spxentry{regular\_set}\spxextra{mpo.critical\_region.CriticalRegion attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.critical_region.CriticalRegion.regular_set}}\pysigline{\sphinxbfcode{\sphinxupquote{regular\_set}}\sphinxbfcode{\sphinxupquote{: Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}
\end{fulllineitems}


\end{fulllineitems}



\subsection{mpo.mp\_program module}
\label{\detokenize{mpo:module-mpo.mp_program}}\label{\detokenize{mpo:mpo-mp-program-module}}\index{module@\spxentry{module}!mpo.mp\_program@\spxentry{mpo.mp\_program}}\index{mpo.mp\_program@\spxentry{mpo.mp\_program}!module@\spxentry{module}}\index{MPLP\_Program (class in mpo.mp\_program)@\spxentry{MPLP\_Program}\spxextra{class in mpo.mp\_program}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPLP_Program}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mpo.mp\_program.}}\sphinxbfcode{\sphinxupquote{MPLP\_Program}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{A\_t}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b\_t}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{F}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{active\_set}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
The standard class for linear multiparametric programming
\index{A (mpo.mp\_program.MPLP\_Program attribute)@\spxentry{A}\spxextra{mpo.mp\_program.MPLP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPLP_Program.A}}\pysigline{\sphinxbfcode{\sphinxupquote{A}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{A\_t (mpo.mp\_program.MPLP\_Program attribute)@\spxentry{A\_t}\spxextra{mpo.mp\_program.MPLP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPLP_Program.A_t}}\pysigline{\sphinxbfcode{\sphinxupquote{A\_t}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{F (mpo.mp\_program.MPLP\_Program attribute)@\spxentry{F}\spxextra{mpo.mp\_program.MPLP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPLP_Program.F}}\pysigline{\sphinxbfcode{\sphinxupquote{F}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{active\_set (mpo.mp\_program.MPLP\_Program attribute)@\spxentry{active\_set}\spxextra{mpo.mp\_program.MPLP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPLP_Program.active_set}}\pysigline{\sphinxbfcode{\sphinxupquote{active\_set}}\sphinxbfcode{\sphinxupquote{: Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{b (mpo.mp\_program.MPLP\_Program attribute)@\spxentry{b}\spxextra{mpo.mp\_program.MPLP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPLP_Program.b}}\pysigline{\sphinxbfcode{\sphinxupquote{b}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{b\_t (mpo.mp\_program.MPLP\_Program attribute)@\spxentry{b\_t}\spxextra{mpo.mp\_program.MPLP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPLP_Program.b_t}}\pysigline{\sphinxbfcode{\sphinxupquote{b\_t}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{c (mpo.mp\_program.MPLP\_Program attribute)@\spxentry{c}\spxextra{mpo.mp\_program.MPLP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPLP_Program.c}}\pysigline{\sphinxbfcode{\sphinxupquote{c}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{display\_latex() (mpo.mp\_program.MPLP\_Program method)@\spxentry{display\_latex()}\spxextra{mpo.mp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPLP_Program.display_latex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display\_latex}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Displaces Latex text of the multiparametric problem

\end{fulllineitems}

\index{display\_warnings() (mpo.mp\_program.MPLP\_Program method)@\spxentry{display\_warnings()}\spxextra{mpo.mp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPLP_Program.display_warnings}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display\_warnings}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Displaces warnings

\end{fulllineitems}

\index{latex() (mpo.mp\_program.MPLP\_Program method)@\spxentry{latex()}\spxextra{mpo.mp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPLP_Program.latex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{latex}}}{}{{ $\rightarrow$ List\DUrole{p}{{[}}str\DUrole{p}{{]}}}}
\sphinxAtStartPar
Generates latex of the multiparametric problem
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns latex of the

\end{description}\end{quote}

\end{fulllineitems}

\index{num\_constraints() (mpo.mp\_program.MPLP\_Program method)@\spxentry{num\_constraints()}\spxextra{mpo.mp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPLP_Program.num_constraints}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{num\_constraints}}}{}{{ $\rightarrow$ int}}
\sphinxAtStartPar
Returns number of constraints

\end{fulllineitems}

\index{num\_t() (mpo.mp\_program.MPLP\_Program method)@\spxentry{num\_t()}\spxextra{mpo.mp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPLP_Program.num_t}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{num\_t}}}{}{{ $\rightarrow$ int}}
\sphinxAtStartPar
Returns number of uncertain variables

\end{fulllineitems}

\index{num\_x() (mpo.mp\_program.MPLP\_Program method)@\spxentry{num\_x()}\spxextra{mpo.mp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPLP_Program.num_x}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{num\_x}}}{}{{ $\rightarrow$ int}}
\sphinxAtStartPar
Returns number of parameters

\end{fulllineitems}

\index{process\_constraints() (mpo.mp\_program.MPLP\_Program method)@\spxentry{process\_constraints()}\spxextra{mpo.mp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPLP_Program.process_constraints}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{process\_constraints}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Removes redundant constraints from the multiparametric programming problem

\end{fulllineitems}

\index{scale\_constraints() (mpo.mp\_program.MPLP\_Program method)@\spxentry{scale\_constraints()}\spxextra{mpo.mp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPLP_Program.scale_constraints}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{scale\_constraints}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Rescales the constraints of the multiparametric problem to ||{[}A|\sphinxhyphen{}F{]}||\_i = 1, in the L2 sense

\end{fulllineitems}

\index{solve\_theta() (mpo.mp\_program.MPLP\_Program method)@\spxentry{solve\_theta()}\spxextra{mpo.mp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPLP_Program.solve_theta}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve\_theta}}}{\emph{\DUrole{n}{theta\_point}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{deterministic\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}glpk\textquotesingle{}}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput}]{\sphinxcrossref{mpo.Solver\_interface.Solver\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
Substitutes theta into the multiparametric problem and solves
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{theta\_point}} \textendash{} an uncertainty realization

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the Solver output of the substituted problem, returns None if not solvable

\end{description}\end{quote}

\end{fulllineitems}

\index{warnings() (mpo.mp\_program.MPLP\_Program method)@\spxentry{warnings()}\spxextra{mpo.mp\_program.MPLP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPLP_Program.warnings}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{warnings}}}{}{{ $\rightarrow$ List\DUrole{p}{{[}}str\DUrole{p}{{]}}}}
\sphinxAtStartPar
Checks the dimensions of the matrices to ensure consistency

\end{fulllineitems}


\end{fulllineitems}

\index{MPQP\_Program (class in mpo.mp\_program)@\spxentry{MPQP\_Program}\spxextra{class in mpo.mp\_program}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPQP_Program}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mpo.mp\_program.}}\sphinxbfcode{\sphinxupquote{MPQP\_Program}}}{\emph{\DUrole{n}{A}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{Q}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{A\_t}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{b\_t}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{F}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{active\_set}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{mpo:mpo.mp_program.MPLP_Program}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{mpo.mp\_program.MPLP\_Program}}}}}

\sphinxAtStartPar
The standard class for quadratic multiparametric programming, inherits from MPLP\_Program
\index{A (mpo.mp\_program.MPQP\_Program attribute)@\spxentry{A}\spxextra{mpo.mp\_program.MPQP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPQP_Program.A}}\pysigline{\sphinxbfcode{\sphinxupquote{A}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{A\_t (mpo.mp\_program.MPQP\_Program attribute)@\spxentry{A\_t}\spxextra{mpo.mp\_program.MPQP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPQP_Program.A_t}}\pysigline{\sphinxbfcode{\sphinxupquote{A\_t}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{F (mpo.mp\_program.MPQP\_Program attribute)@\spxentry{F}\spxextra{mpo.mp\_program.MPQP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPQP_Program.F}}\pysigline{\sphinxbfcode{\sphinxupquote{F}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{active\_set (mpo.mp\_program.MPQP\_Program attribute)@\spxentry{active\_set}\spxextra{mpo.mp\_program.MPQP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPQP_Program.active_set}}\pysigline{\sphinxbfcode{\sphinxupquote{active\_set}}\sphinxbfcode{\sphinxupquote{: Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{b (mpo.mp\_program.MPQP\_Program attribute)@\spxentry{b}\spxextra{mpo.mp\_program.MPQP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPQP_Program.b}}\pysigline{\sphinxbfcode{\sphinxupquote{b}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{b\_t (mpo.mp\_program.MPQP\_Program attribute)@\spxentry{b\_t}\spxextra{mpo.mp\_program.MPQP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPQP_Program.b_t}}\pysigline{\sphinxbfcode{\sphinxupquote{b\_t}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{c (mpo.mp\_program.MPQP\_Program attribute)@\spxentry{c}\spxextra{mpo.mp\_program.MPQP\_Program attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPQP_Program.c}}\pysigline{\sphinxbfcode{\sphinxupquote{c}}\sphinxbfcode{\sphinxupquote{: numpy.ndarray}}}
\end{fulllineitems}

\index{latex() (mpo.mp\_program.MPQP\_Program method)@\spxentry{latex()}\spxextra{mpo.mp\_program.MPQP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPQP_Program.latex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{latex}}}{}{{ $\rightarrow$ List\DUrole{p}{{[}}str\DUrole{p}{{]}}}}
\sphinxAtStartPar
Creates a latex output for the multiparametric problem

\end{fulllineitems}

\index{process\_constraints() (mpo.mp\_program.MPQP\_Program method)@\spxentry{process\_constraints()}\spxextra{mpo.mp\_program.MPQP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPQP_Program.process_constraints}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{process\_constraints}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Removes redundant constraints from the multiparametric programming problem

\end{fulllineitems}

\index{solve\_theta() (mpo.mp\_program.MPQP\_Program method)@\spxentry{solve\_theta()}\spxextra{mpo.mp\_program.MPQP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPQP_Program.solve_theta}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve\_theta}}}{\emph{\DUrole{n}{theta\_point}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}{\hyperref[\detokenize{mpo.solver_interface:mpo.solver_interface.solver_utils.SolverOutput}]{\sphinxcrossref{mpo.Solver\_interface.Solver\_utils.SolverOutput}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
Substitutes theta into the multiparametric problem and solves
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{theta\_point}} \textendash{} an uncertainty realization

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the Solver output of the substituted problem, returns None if not solvable

\end{description}\end{quote}

\end{fulllineitems}

\index{warnings() (mpo.mp\_program.MPQP\_Program method)@\spxentry{warnings()}\spxextra{mpo.mp\_program.MPQP\_Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.mp_program.MPQP_Program.warnings}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{warnings}}}{}{{ $\rightarrow$ List\DUrole{p}{{[}}str\DUrole{p}{{]}}}}
\sphinxAtStartPar
Checks the dimensions of the matrices to ensure consistency

\end{fulllineitems}


\end{fulllineitems}



\subsection{mpo.plot module}
\label{\detokenize{mpo:module-mpo.plot}}\label{\detokenize{mpo:mpo-plot-module}}\index{module@\spxentry{module}!mpo.plot@\spxentry{mpo.plot}}\index{mpo.plot@\spxentry{mpo.plot}!module@\spxentry{module}}\index{gen\_vertices() (in module mpo.plot)@\spxentry{gen\_vertices()}\spxextra{in module mpo.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.plot.gen_vertices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.plot.}}\sphinxbfcode{\sphinxupquote{gen\_vertices}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.solution.Solution}]{\sphinxcrossref{mpo.solution.Solution}}}}}}{}
\sphinxAtStartPar
Generates the vertices associated with the mixed
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} a multiparametric region

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a list of a collection of vertices sorted counterclockwise that correspond to the specific region

\end{description}\end{quote}

\end{fulllineitems}

\index{parametric\_plot() (in module mpo.plot)@\spxentry{parametric\_plot()}\spxextra{in module mpo.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.plot.parametric_plot}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.plot.}}\sphinxbfcode{\sphinxupquote{parametric\_plot}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.solution.Solution}]{\sphinxcrossref{mpo.solution.Solution}}}}}, \emph{\DUrole{n}{save\_path}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{show}\DUrole{o}{=}\DUrole{default_value}{True}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Makes a simple plot from a solution
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} a multiparametric solution

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{save\_path}} \textendash{} if specified saves the plot in the directory

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{show}} \textendash{} Keyword argument, if True displays the plot otherwise does not display

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
no return, creates graph of solution

\end{description}\end{quote}

\end{fulllineitems}

\index{plotly\_plot() (in module mpo.plot)@\spxentry{plotly\_plot()}\spxextra{in module mpo.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.plot.plotly_plot}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.plot.}}\sphinxbfcode{\sphinxupquote{plotly\_plot}}}{\emph{\DUrole{n}{solution}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.solution.Solution}]{\sphinxcrossref{mpo.solution.Solution}}}}}, \emph{\DUrole{n}{save\_path}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{show}\DUrole{o}{=}\DUrole{default_value}{True}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Makes a plot via the plotly library, this is good for interactive figures that you can embed into webpages and handle interactively
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{solution}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{save\_path}} \textendash{} Keyword argument, if a directory path is specified it will save a html copy and a png to that directory

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{show}} \textendash{} Keyword argument, if True displays the plot otherwise does not display

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{sort\_clockwise() (in module mpo.plot)@\spxentry{sort\_clockwise()}\spxextra{in module mpo.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.plot.sort_clockwise}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.plot.}}\sphinxbfcode{\sphinxupquote{sort\_clockwise}}}{\emph{\DUrole{n}{vertices}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}}{{ $\rightarrow$ List\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
Sorts the vertices in clockwise order, fixes crossed polytopes in rendering
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{vertices}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}



\subsection{mpo.problem\_generator module}
\label{\detokenize{mpo:module-mpo.problem_generator}}\label{\detokenize{mpo:mpo-problem-generator-module}}\index{module@\spxentry{module}!mpo.problem\_generator@\spxentry{mpo.problem\_generator}}\index{mpo.problem\_generator@\spxentry{mpo.problem\_generator}!module@\spxentry{module}}\index{generate\_mplp() (in module mpo.problem\_generator)@\spxentry{generate\_mplp()}\spxextra{in module mpo.problem\_generator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.problem_generator.generate_mplp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.problem\_generator.}}\sphinxbfcode{\sphinxupquote{generate\_mplp}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{2}}, \emph{\DUrole{n}{t}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{2}}, \emph{\DUrole{n}{m}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{10}}}{{ $\rightarrow$ {\hyperref[\detokenize{mpo:mpo.mp_program.MPLP_Program}]{\sphinxcrossref{mpo.mp\_program.MPLP\_Program}}}}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} number of parameters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} number of uncertain variables

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{m}} \textendash{} number of constraints

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{generate\_mpqp() (in module mpo.problem\_generator)@\spxentry{generate\_mpqp()}\spxextra{in module mpo.problem\_generator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.problem_generator.generate_mpqp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{mpo.problem\_generator.}}\sphinxbfcode{\sphinxupquote{generate\_mpqp}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{2}}, \emph{\DUrole{n}{t}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{2}}, \emph{\DUrole{n}{m}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{10}}}{{ $\rightarrow$ {\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}}}
\sphinxAtStartPar
Generates a random mpqp problem with of the following characteristics
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} number of x dimensions

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} number of theta dimensions

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{m}} \textendash{} number of constraints

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A random mpqp problem of the specified type

\end{description}\end{quote}

\end{fulllineitems}



\subsection{mpo.settings module}
\label{\detokenize{mpo:module-mpo.settings}}\label{\detokenize{mpo:mpo-settings-module}}\index{module@\spxentry{module}!mpo.settings@\spxentry{mpo.settings}}\index{mpo.settings@\spxentry{mpo.settings}!module@\spxentry{module}}

\subsection{mpo.solution module}
\label{\detokenize{mpo:module-mpo.solution}}\label{\detokenize{mpo:mpo-solution-module}}\index{module@\spxentry{module}!mpo.solution@\spxentry{mpo.solution}}\index{mpo.solution@\spxentry{mpo.solution}!module@\spxentry{module}}\index{Solution (class in mpo.solution)@\spxentry{Solution}\spxextra{class in mpo.solution}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.solution.Solution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mpo.solution.}}\sphinxbfcode{\sphinxupquote{Solution}}}{\emph{\DUrole{n}{program}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}{\hyperref[\detokenize{mpo:mpo.mp_program.MPLP_Program}]{\sphinxcrossref{mpo.mp\_program.MPLP\_Program}}}\DUrole{p}{, }{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{critical\_regions}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{mpo:mpo.critical_region.CriticalRegion}]{\sphinxcrossref{mpo.critical\_region.CriticalRegion}}}\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
The Solution object is the output of multiparametric solvers, it contains all of the critical regions as well as holds a copy of the original problem that was solved
\index{add\_region() (mpo.solution.Solution method)@\spxentry{add\_region()}\spxextra{mpo.solution.Solution method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.solution.Solution.add_region}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_region}}}{\emph{\DUrole{n}{region}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{mpo:mpo.critical_region.CriticalRegion}]{\sphinxcrossref{mpo.critical\_region.CriticalRegion}}}}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Adds a region to the solution
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{region}} \textendash{} region to add to the solution

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{critical\_regions (mpo.solution.Solution attribute)@\spxentry{critical\_regions}\spxextra{mpo.solution.Solution attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.solution.Solution.critical_regions}}\pysigline{\sphinxbfcode{\sphinxupquote{critical\_regions}}\sphinxbfcode{\sphinxupquote{: List\DUrole{p}{{[}}{\hyperref[\detokenize{mpo:mpo.critical_region.CriticalRegion}]{\sphinxcrossref{mpo.critical\_region.CriticalRegion}}}\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{evaluate() (mpo.solution.Solution method)@\spxentry{evaluate()}\spxextra{mpo.solution.Solution method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.solution.Solution.evaluate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{evaluate}}}{\emph{\DUrole{n}{theta\_point}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}None\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}
\sphinxAtStartPar
returns the optimal x* from the solution
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{theta\_point}} \textendash{} an uncertainty realization

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the calculated x* from theta

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_region() (mpo.solution.Solution method)@\spxentry{get\_region()}\spxextra{mpo.solution.Solution method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.solution.Solution.get_region}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_region}}}{\emph{\DUrole{n}{theta\_point}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}None\DUrole{p}{, }{\hyperref[\detokenize{mpo:mpo.critical_region.CriticalRegion}]{\sphinxcrossref{mpo.critical\_region.CriticalRegion}}}\DUrole{p}{{]}}}}
\sphinxAtStartPar
Find the critical region in the solution that corresponds to the theta provided
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{theta\_point}} \textendash{} an uncertainty realization

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the region that contains theta

\end{description}\end{quote}

\end{fulllineitems}

\index{program (mpo.solution.Solution attribute)@\spxentry{program}\spxextra{mpo.solution.Solution attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.solution.Solution.program}}\pysigline{\sphinxbfcode{\sphinxupquote{program}}\sphinxbfcode{\sphinxupquote{: Union\DUrole{p}{{[}}{\hyperref[\detokenize{mpo:mpo.mp_program.MPLP_Program}]{\sphinxcrossref{mpo.mp\_program.MPLP\_Program}}}\DUrole{p}{, }{\hyperref[\detokenize{mpo:mpo.mp_program.MPQP_Program}]{\sphinxcrossref{mpo.mp\_program.MPQP\_Program}}}\DUrole{p}{{]}}}}}
\end{fulllineitems}

\index{verify\_solution() (mpo.solution.Solution method)@\spxentry{verify\_solution()}\spxextra{mpo.solution.Solution method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.solution.Solution.verify_solution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{verify\_solution}}}{}{}
\end{fulllineitems}

\index{verify\_theta() (mpo.solution.Solution method)@\spxentry{verify\_theta()}\spxextra{mpo.solution.Solution method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mpo:mpo.solution.Solution.verify_theta}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{verify\_theta}}}{\emph{\DUrole{n}{theta\_point}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ bool}}
\sphinxAtStartPar
Checks that the result of the solution is consistent with theta substituted multiparametric problem
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{theta\_point}} \textendash{} an uncertainty realization

\item[{Returns}] \leavevmode
\sphinxAtStartPar
True if they are the same, False if they are different

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Module contents}
\label{\detokenize{mpo:module-mpo}}\label{\detokenize{mpo:module-contents}}\index{module@\spxentry{module}!mpo@\spxentry{mpo}}\index{mpo@\spxentry{mpo}!module@\spxentry{module}}

\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{m}
\item\relax\sphinxstyleindexentry{mpo}\sphinxstyleindexpageref{mpo:\detokenize{module-mpo}}
\item\relax\sphinxstyleindexentry{mpo.critical\_region}\sphinxstyleindexpageref{mpo:\detokenize{module-mpo.critical_region}}
\item\relax\sphinxstyleindexentry{mpo.geometry}\sphinxstyleindexpageref{mpo.geometry:\detokenize{module-mpo.geometry}}
\item\relax\sphinxstyleindexentry{mpo.geometry.polytope\_operations}\sphinxstyleindexpageref{mpo.geometry:\detokenize{module-mpo.geometry.polytope_operations}}
\item\relax\sphinxstyleindexentry{mpo.mp\_program}\sphinxstyleindexpageref{mpo:\detokenize{module-mpo.mp_program}}
\item\relax\sphinxstyleindexentry{mpo.mp\_solvers}\sphinxstyleindexpageref{mpo.mp_solvers:\detokenize{module-mpo.mp_solvers}}
\item\relax\sphinxstyleindexentry{mpo.mp\_solvers.mpqp\_combinatorial}\sphinxstyleindexpageref{mpo.mp_solvers:\detokenize{module-mpo.mp_solvers.mpqp_combinatorial}}
\item\relax\sphinxstyleindexentry{mpo.mp\_solvers.mpqp\_geometric}\sphinxstyleindexpageref{mpo.mp_solvers:\detokenize{module-mpo.mp_solvers.mpqp_geometric}}
\item\relax\sphinxstyleindexentry{mpo.mp\_solvers.mpqp\_graph}\sphinxstyleindexpageref{mpo.mp_solvers:\detokenize{module-mpo.mp_solvers.mpqp_graph}}
\item\relax\sphinxstyleindexentry{mpo.mp\_solvers.mpqp\_parrallel\_combinatorial}\sphinxstyleindexpageref{mpo.mp_solvers:\detokenize{module-mpo.mp_solvers.mpqp_parrallel_combinatorial}}
\item\relax\sphinxstyleindexentry{mpo.mp\_solvers.mpqp\_parrallel\_graph}\sphinxstyleindexpageref{mpo.mp_solvers:\detokenize{module-mpo.mp_solvers.mpqp_parrallel_graph}}
\item\relax\sphinxstyleindexentry{mpo.mp\_solvers.solve\_mplp}\sphinxstyleindexpageref{mpo.mp_solvers:\detokenize{module-mpo.mp_solvers.solve_mplp}}
\item\relax\sphinxstyleindexentry{mpo.mp\_solvers.solve\_mpqp}\sphinxstyleindexpageref{mpo.mp_solvers:\detokenize{module-mpo.mp_solvers.solve_mpqp}}
\item\relax\sphinxstyleindexentry{mpo.plot}\sphinxstyleindexpageref{mpo:\detokenize{module-mpo.plot}}
\item\relax\sphinxstyleindexentry{mpo.problem\_generator}\sphinxstyleindexpageref{mpo:\detokenize{module-mpo.problem_generator}}
\item\relax\sphinxstyleindexentry{mpo.settings}\sphinxstyleindexpageref{mpo:\detokenize{module-mpo.settings}}
\item\relax\sphinxstyleindexentry{mpo.solution}\sphinxstyleindexpageref{mpo:\detokenize{module-mpo.solution}}
\item\relax\sphinxstyleindexentry{mpo.Solver\_interface}\sphinxstyleindexpageref{mpo.solver_interface:\detokenize{module-mpo.solver_interface}}
\item\relax\sphinxstyleindexentry{mpo.Solver\_interface.cvxopt\_interface}\sphinxstyleindexpageref{mpo.solver_interface:\detokenize{module-mpo.solver_interface.cvxopt_interface}}
\item\relax\sphinxstyleindexentry{mpo.Solver\_interface.gurobi\_solver\_interface}\sphinxstyleindexpageref{mpo.solver_interface:\detokenize{module-mpo.solver_interface.gurobi_solver_interface}}
\item\relax\sphinxstyleindexentry{mpo.Solver\_interface.Solver\_interface}\sphinxstyleindexpageref{mpo.solver_interface:\detokenize{module-mpo.solver_interface.solver_interface}}
\item\relax\sphinxstyleindexentry{mpo.Solver\_interface.Solver\_utils}\sphinxstyleindexpageref{mpo.solver_interface:\detokenize{module-mpo.solver_interface.solver_utils}}
\item\relax\sphinxstyleindexentry{mpo.upop}\sphinxstyleindexpageref{mpo.upop:\detokenize{module-mpo.upop}}
\item\relax\sphinxstyleindexentry{mpo.upop.language\_generation}\sphinxstyleindexpageref{mpo.upop:\detokenize{module-mpo.upop.language_generation}}
\item\relax\sphinxstyleindexentry{mpo.upop.point\_location}\sphinxstyleindexpageref{mpo.upop:\detokenize{module-mpo.upop.point_location}}
\item\relax\sphinxstyleindexentry{mpo.upop.ucontroller}\sphinxstyleindexpageref{mpo.upop:\detokenize{module-mpo.upop.ucontroller}}
\item\relax\sphinxstyleindexentry{mpo.upop.upop\_utils}\sphinxstyleindexpageref{mpo.upop:\detokenize{module-mpo.upop.upop_utils}}
\item\relax\sphinxstyleindexentry{mpo.utils}\sphinxstyleindexpageref{mpo.utils:\detokenize{module-mpo.utils}}
\item\relax\sphinxstyleindexentry{mpo.utils.chebyshev\_ball}\sphinxstyleindexpageref{mpo.utils:\detokenize{module-mpo.utils.chebyshev_ball}}
\item\relax\sphinxstyleindexentry{mpo.utils.constraint\_utilities}\sphinxstyleindexpageref{mpo.utils:\detokenize{module-mpo.utils.constraint_utilities}}
\item\relax\sphinxstyleindexentry{mpo.utils.general\_utils}\sphinxstyleindexpageref{mpo.utils:\detokenize{module-mpo.utils.general_utils}}
\item\relax\sphinxstyleindexentry{mpo.utils.geometric}\sphinxstyleindexpageref{mpo.utils:\detokenize{module-mpo.utils.geometric}}
\item\relax\sphinxstyleindexentry{mpo.utils.mpqp\_utils}\sphinxstyleindexpageref{mpo.utils:\detokenize{module-mpo.utils.mpqp_utils}}
\item\relax\sphinxstyleindexentry{mpo.utils.Solver\_utils}\sphinxstyleindexpageref{mpo.utils:\detokenize{module-mpo.utils.solver_utils}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}